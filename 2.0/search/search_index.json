{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#classppTitle","title":"Overload your Classes.","text":"<p>     Tired of the traditional class system on Roblox?     Tired of learning complex systems, and wish for something easier?     Wish to do OOP in the right way, like in many languages such as C++?     (New Type Solver Beta) </p> <p>     Then you're in the right place.     Introducing: Class++.     Classes were never this easy to create, and advanced before on Roblox. </p> Getting Started Download"},{"location":"api-reference/gettingStarted/","title":"API Reference","text":"<p>Welcome to the API Reference section of Class++ !  This section is more technical, and is not recommended for beginners. Check out the tutorials for a guided experience!</p> <p>You can use the left bar to find the API members grouped by their category. Additionally, you can use the search bar to find a specific API member.</p>"},{"location":"api-reference/classFunctions/mainModule/abstract/","title":"abstract","text":"<p>abstract : class</p> <p><pre><code>function classpp.abstract(classTable: {class}): class\n</code></pre> Marks the given <code>class</code> or <code>class</code>es as abstract. If given multiple, then the first class will be returned.</p>"},{"location":"api-reference/classFunctions/mainModule/abstract/#default-syntax","title":"Default Syntax","text":"<pre><code>local Car = abstract { class \"Car\" {\n    Public = {\n        ...\n    },\n    ...\n}}\n</code></pre>"},{"location":"api-reference/classFunctions/mainModule/abstract/#without-syntax-sugar","title":"Without Syntax Sugar","text":"<pre><code>local Car = abstract({class(\"Car\")({\n    Public = {\n        ...\n    },\n    ...\n})})\n</code></pre>"},{"location":"api-reference/classFunctions/mainModule/abstract/#parameters","title":"Parameters","text":""},{"location":"api-reference/classFunctions/mainModule/class/","title":"class","text":"<p>class : class</p> <pre><code>function classpp.class(className: string): (classData: classData) -&gt; class\n</code></pre> <p>Creates a new <code>class</code> with the given <code>classData</code> table.</p>"},{"location":"api-reference/classFunctions/mainModule/class/#default-syntax","title":"Default Syntax","text":"<pre><code>local Class = class \"Class\" {\n    constructor = function(self)\n        ...\n    end,\n    destructor = function(self)\n        ...\n    end,\n    Public = {\n        ...\n    },\n    Private = {\n        ...\n    },\n    Protected = {\n        ...\n    },\n    Friend = {\n        ...\n    }\n}\n</code></pre>"},{"location":"api-reference/classFunctions/mainModule/class/#without-syntax-sugar","title":"Without Syntax Sugar","text":"<pre><code>local Class = class(\"Class\")({\n    constructor = function(self)\n        ...\n    end,\n    destructor = function(self)\n        ...\n    end,\n    Public = {\n        ...\n    },\n    Private = {\n        ...\n    },\n    Protected = {\n        ...\n    },\n    Friend = {\n        ...\n    }\n})\n</code></pre>"},{"location":"api-reference/classFunctions/mainModule/class/#parameters","title":"Parameters","text":""},{"location":"api-reference/classFunctions/mainModule/final/","title":"final","text":"<p>final : class</p> <pre><code>function classpp.final(classTable: {class}): class\n</code></pre> <p>Marks the given <code>class</code> or <code>class</code>es as final. If given multiple, then the first class will be returned.</p>"},{"location":"api-reference/classFunctions/mainModule/final/#default-syntax","title":"Default Syntax","text":"<pre><code>local Car = final { class \"Car\" {\n    Public = {\n        ...\n    },\n    ...\n}}\n</code></pre>"},{"location":"api-reference/classFunctions/mainModule/final/#without-syntax-sugar","title":"Without Syntax Sugar","text":"<pre><code>local Car = final({class(\"Car\")({\n    Public = {\n        ...\n    },\n    ...\n})})\n</code></pre>"},{"location":"api-reference/classFunctions/mainModule/final/#parameters","title":"Parameters","text":""},{"location":"api-reference/classFunctions/mainModule/getClass/","title":"getClass","text":"<p>getClass : class</p> <pre><code>function classpp.getClass(className: string): class\n</code></pre> <p>Returns the <code>class</code> with the given <code>className</code>, if it exists.</p>"},{"location":"api-reference/classFunctions/mainModule/getClass/#default-syntax","title":"Default syntax","text":"<pre><code>local Class = ClassPP.getClass(\"Class\")\n</code></pre>"},{"location":"api-reference/classFunctions/mainModule/getClass/#parameters","title":"Parameters","text":""},{"location":"api-reference/classFunctions/type/type/","title":"type","text":"<p> type :string </p> <pre><code>function Type.type(object: any): string\n</code></pre> <p>Returns the true type of the given <code>object</code>. Behaves the same as the built-in <code>type()</code> function, but with additional support for <code>class</code>es and <code>object</code>s.</p>"},{"location":"api-reference/classFunctions/type/type/#default-syntax","title":"Default syntax","text":"<pre><code>local objectType = ClassPP.Type.type(object)\n</code></pre>"},{"location":"api-reference/classFunctions/type/type/#parameters","title":"Parameters","text":""},{"location":"api-reference/classFunctions/type/typeof/","title":"typeof","text":"<p> typeof :string </p> <pre><code>function Type.typeof(object: any): string\n</code></pre> <p>Returns the type of the given <code>object</code>. Behaves the same as the built-in Roblox <code>typeof()</code> function, but with additional support for <code>class</code>es and <code>object</code>s.</p>"},{"location":"api-reference/classFunctions/type/typeof/#default-syntax","title":"Default syntax","text":"<pre><code>local objectType = ClassPP.Type.typeof(object)\n</code></pre>"},{"location":"api-reference/classFunctions/type/typeof/#parameters","title":"Parameters","text":""},{"location":"api-reference/classFunctions/util/checkFriendship/","title":"checkFriendship","text":"<p>checkFriendship : boolean</p> <pre><code>function Util.checkFriendship(class: class, methodName: string, method: () -&gt; (), classes: {[string]: class}): boolean\n</code></pre> <p>This function checks if the given <code>method</code> and it's <code>methodName</code> is in the given <code>class</code>'s <code>Friend</code> access specifier.</p>"},{"location":"api-reference/classFunctions/util/checkFriendship/#default-syntax","title":"Default syntax","text":"<pre><code>local isAFriend = ClassPP.Util.checkFriendship(class, methodName, method, classes)\n</code></pre>"},{"location":"api-reference/classFunctions/util/checkFriendship/#parameters","title":"Parameters","text":""},{"location":"api-reference/classFunctions/util/checkInheritance/","title":"checkInheritance","text":"<p>checkInheritance : boolean</p> <pre><code>function Util.checkInheritance(class: class, classOrMethod: class | () -&gt; ()): boolean\n</code></pre> <p>If the <code>classOrMethod</code> is a <code>class</code>, the function checks if the given <code>class</code> has been inherited from <code>classOrMethod</code>, or if the <code>classOrMethod</code> is a method, then it simply checks if any of the classes that the given <code>class</code> inherits from contains the method.</p>"},{"location":"api-reference/classFunctions/util/checkInheritance/#default-syntax","title":"Default syntax","text":"<pre><code>local isInherited = ClassPP.Util.checkInheritance(classOne, classTwo) -- For classes\nlocal isInherited = ClassPP.Util.checkInheritance(class, method) -- For methods\n</code></pre>"},{"location":"api-reference/classFunctions/util/checkInheritance/#parameters","title":"Parameters","text":""},{"location":"api-reference/classFunctions/util/inClassScope/","title":"inClassScope","text":"<p>inClassScope : boolean</p> <pre><code>function Util.inClassScope(class: class, includeInherited: boolean, includeFriend: boolean, classes: {[string]: class}?, defaultLevel: number?): boolean\n</code></pre> <p>This function checks if the current thread is allowed to access a specific <code>class</code> property from a certain access specifier.</p>"},{"location":"api-reference/classFunctions/util/inClassScope/#default-syntax","title":"Default syntax","text":"<pre><code>local isAllowed = Util.inClassScope(class, false, true, Classes) -- For the Private access specifier\n</code></pre>"},{"location":"api-reference/classFunctions/util/inClassScope/#parameters","title":"Parameters","text":""},{"location":"api-reference/dataTypes/class/","title":"Class","text":"<p>A <code>class</code> object created from the <code>class()</code> function. Contains all of the members given from the <code>classData</code>.</p>"},{"location":"api-reference/dataTypes/class/#summary","title":"Summary","text":""},{"location":"api-reference/dataTypes/class/#properties","title":"Properties","text":"<p> Name : string</p> <p>\u00a0An unique identifier of the <code>class</code>.</p> Inherits : TableRead Only <p>\u00a0A table that contains classes that the <code>class</code> inherits from.</p> Friends : TableRead Only <p>\u00a0A table that contains functions or classes that can access <code>Private</code> and <code>Protected</code> members of the <code>class</code>.</p> Statics : TableRead Only <p>\u00a0A table that contains the static members of the <code>class</code>. These members can only be called through the <code>class</code> object.</p>"},{"location":"api-reference/dataTypes/class/#methods","title":"Methods","text":"<p> new (...) : any</p> <p>\u00a0Returns a new <code>object</code> that contains all of the members given from the <code>class</code>.</p> <p> extends (className: string) : (classData: classData) : class</p> <p>\u00a0(Deprecated) Creates a new <code>class</code> that inherits the <code>class</code> it's been created from. Contains all <code>Public</code> and <code>Protected</code> members of that base <code>class</code>.</p> <p> overload (accessSpecifier: string, name: string, functionTable: {(...any) -&gt; (any)}) : void</p> <p>\u00a0Creates an overloaded function with the given access specifier, name and the function table, and saves it to the <code>class</code>'s <code>classData</code>.</p> <p> static (accessSpecifier: string, name: string, property: any) : void</p> <p>\u00a0Creates a new static <code>class</code> member that can only be accessable through the <code>class</code> object. </p>"},{"location":"api-reference/dataTypes/class/#properties_1","title":"Properties","text":""},{"location":"api-reference/dataTypes/class/#name","title":"Name","text":"<p>string</p> <p>This is an unique identifier of the <code>class</code>. Using the <code>getClass()</code> function with this property will retrieve the desired <code>class</code>. Since names are unique, for every class, you have to use a different name.</p>"},{"location":"api-reference/dataTypes/class/#inherits","title":"Inherits","text":"<p>Table</p> Read Only <p>This table contains all the classes that the <code>class</code> is inheriting from. Currently, multiple class inheritance is not supported, so a <code>class</code> can only inherit from one <code>class</code>, but it may be different in the future.</p>"},{"location":"api-reference/dataTypes/class/#friends","title":"Friends","text":"<p>Table</p> Read Only <p>This table contains all the functions and the classes that can access all of the <code>Public</code> and <code>Protected</code> members of the <code>class</code>.</p>"},{"location":"api-reference/dataTypes/class/#statics","title":"Statics","text":"<p>Table</p> Read Only <p>This table contains all the members that are static, meaning they only belong to the <code>class</code>. These members won't replicate to the objects, and can only be called through the <code>class</code> object.</p>"},{"location":"api-reference/dataTypes/class/#methods_1","title":"Methods","text":""},{"location":"api-reference/dataTypes/class/#new","title":"new","text":"<p>any</p> <p>Creates and returns a new <code>object</code> that contains all of the members given from the <code>class</code>.</p>  Returns"},{"location":"api-reference/dataTypes/object/","title":"Object","text":"<p>An <code>object</code> created from the <code>class.new()</code> function. Contains all of the members given from the <code>class</code> object.</p> <p>Warning</p> <p>An <code>object</code>'s <code>metatable</code> cannot be deleted or changed. This is to prevent access to the <code>Internal</code> members, logic that keeps the <code>object</code> secure, and the logic on how it works. An <code>object</code> will always belong to the base type <code>userdata</code>.</p>"},{"location":"api-reference/dataTypes/object/#summary","title":"Summary","text":""},{"location":"api-reference/dataTypes/object/#properties","title":"Properties","text":"__locked : booleanInternal <p>\u00a0Indicates if an <code>object</code> is locked. </p> __type : stringInternal <p>\u00a0Indicates the <code>class</code> type of the <code>object</code>. </p> objectData : TableNo Direct Access <p>\u00a0The <code>object</code>'s data table that you can access by indexing the <code>object</code> with the member's name. (<code>object.member</code> or <code>object[\"member\"]</code>)</p>"},{"location":"api-reference/dataTypes/object/#methods","title":"Methods","text":"constructor (...) : voidInternal <p>\u00a0The constructor function of the <code>object</code>, if it exists. Cannot be directly called.</p> destructor () : voidInternal <p>\u00a0The destructor function of the <code>object</code>, if it exists. Cannot be directly called.</p> <p> Destroy () : void</p> <p>\u00a0Calls the <code>object</code>'s <code>destructor</code> function, destroys all the instances inside the <code>objectData</code> and clears it, and sets the <code>__locked</code> property to <code>true</code>.</p>"},{"location":"api-reference/dataTypes/object/#properties_1","title":"Properties","text":""},{"location":"api-reference/dataTypes/object/#__locked","title":"__locked","text":"<p>boolean</p> Internal <p>Indicates if an <code>object</code> has been locked. If set to true, the <code>object</code>'s metamethods will no longer work and all the members will become unaccessable. </p>"},{"location":"api-reference/dataTypes/object/#__type","title":"__type","text":"<p>string</p> Internal <p>Indicates the <code>class</code> type of the <code>object</code>. Can be used to determine which <code>class</code> the <code>object</code> belongs to by using the <code>Type.typeof()</code> function.</p>"},{"location":"api-reference/dataTypes/object/#objectdata","title":"objectData","text":"<p>Table</p> No Direct Access <p>The <code>object</code>'s data table that stores every access specifier, and the members inside them. This data table cannot be accessed directly, so you have to index the <code>object</code> by using <code>object.member</code> or <code>object[\"member\"]</code> methods to access it.</p>"},{"location":"api-reference/dataTypes/object/#methods_1","title":"Methods","text":""},{"location":"api-reference/dataTypes/object/#constructor","title":"constructor","text":"<p>void</p> Internal <p>The <code>constructor</code> function inside the <code>object</code>, if it has been set in the <code>classData</code> table. This function is internal, so it will only be called when the <code>object</code> is created by using the <code>class.new(...)</code> function.</p>  Returns"},{"location":"api-reference/types/classData/","title":"classData","text":"<pre><code>export type classData = {\n    constructor: (self: any, ...any) -&gt; ()?,\n    destructor: (self: any) -&gt; ()?,\n    Public: {[any]: any}?,\n    Private: {[any]: any}?,\n    Protected: {[any]: any}?,\n    Friend: {any}?\n}\n</code></pre> <p>The <code>classData</code> table that is given to the <code>class()</code> function that contains data about the desired <code>class</code>.</p>"},{"location":"api-reference/types/classData/#properties","title":"Properties","text":""},{"location":"api-reference/types/classData/#constructor","title":"constructor","text":"<p>(self: any, ...any) -&gt; ()?</p> <p>The <code>constructor</code> function that will be called when an <code>object</code> gets created.</p>"},{"location":"api-reference/types/classData/#destructor","title":"destructor","text":"<p>(self: any) -&gt; ()?</p> <p>The <code>destructor</code> function that will be called when an <code>object</code> gets destroyed.</p>"},{"location":"api-reference/types/classData/#public","title":"Public","text":"<p>{[any]: any}</p> <p>The access specifier that contains properties that can be globally accessable.</p>"},{"location":"api-reference/types/classData/#private","title":"Private","text":"<p>{[any]: any}?</p> <p>The access specifier that contains properties that can only be accessed inside the <code>class</code>.</p>"},{"location":"api-reference/types/classData/#protected","title":"Protected","text":"<p>{[any]: any}?</p> <p>The access specifier that contains properties that can only be accessed inside the <code>class</code> and inherited classes.</p>"},{"location":"api-reference/types/classData/#friend","title":"Friend","text":"<p>{any}?</p> <p>The access specifier that contains functions and classes that can access the <code>class</code>'s <code>Private</code> properties.</p>"},{"location":"tutorials/accessSpecifiers/","title":"Access Specifiers","text":"<p>Unlike any other class module or system on Roblox, Class++ comes with an Access Specifier system, like in C++, it provides you a way to modify the access control of a member. There are currently 4 access specifiers in Class++: <code>Public</code>, <code>Private</code>, <code>Protected</code>, and <code>Friend</code>. (You will learn about <code>Protected</code> and <code>Friend</code> later.)</p>"},{"location":"tutorials/accessSpecifiers/#public-access-specifier","title":"Public Access Specifier","text":"<p>Like you have seen in the examples on the previous pages, a Public access specifier allows anyone to access a member. Whether it be from a function inside the class or from the script's main thread, the member is accessible and can be modified.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    }\n}\n\nlocal newCar = Car.new()\nnewCar.Brand = \"Tesla\"\n</code></pre> <p>In this example, we created a new class with a Public member <code>Brand</code> that has the default value of <code>Lamborghini</code>. Then we created a new object from this class and modified the <code>Brand</code> member of this object. Now the value is set to <code>Tesla</code>.</p>"},{"location":"tutorials/accessSpecifiers/#private-access-specifier","title":"Private Access Specifier","text":"<p>Private access specifier allows you to hide a member from anyone outside from that class. No one besides the class members can access this member or modify it.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal newCar = Car.new()\nnewCar.License_Plate = \"YYYY\" -- This will error!\n</code></pre> <p>In this example, we updated the previous class with a private member named <code>License_Plate</code>, this member is private and can only be accessed by the class members, so trying to access or modify it outside of the class will cause an error.</p> <p>Warning</p> <p>A member (property/attribute) can be declared only once. This means a member can only be defined under one access specifier. Attempting to declare another member with the same name on a different access specifier will error.</p>"},{"location":"tutorials/classConstructors/","title":"Class Constructors and Destructors","text":"<p>Up until this point, when we created an object from a class, we always updated the object outside of the class, and we had to define a custom function every single time if we wanted to update or access a private member. This is the same for when we want to destroy an object too. This can be tedious after some time, as constantly having to do these steps over and over again for each class will get tiring. Fortunately, to solve these issues, there are 2 special functions that you can define in every class: <code>constructor</code> and <code>destructor</code>.</p>"},{"location":"tutorials/classConstructors/#class-constructors","title":"Class Constructors","text":"<p>A constructor is a special function that gets called when an object is created. To create a constructor, you have to specifically define a function called <code>constructor</code> outside of the Access Specifiers.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    constructor = function(self)\n        self.License_Plate = \"YYYY\"\n    end,\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal newCar = Car.new()\n</code></pre> <p>When <code>Car.new()</code> is called, the function will automatically call the constructor function. </p>"},{"location":"tutorials/classConstructors/#constructor-parameters","title":"Constructor Parameters","text":"<p>Constructors, like regular class functions, take parameters. (Just like regular class functions, the first argument will always be self.) This can be useful for setting inital values for certain members.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    constructor = function(self, brand, model, licensePlate)\n        self.License_Plate = licensePlate\n        self.Brand = brand\n        self.Model = model\n    end,\n    Public = {\n        Brand = \"\",\n        Model = \"\",\n        License_Plate = \"\"\n    },\n}\n\nlocal newCar = Car.new(\"ABCD\", \"Ford\", \"Mustang\")\nprint(newCar.Brand, newCar.Model, newCar.License_Plate) -- Prints \"ABCD, Ford, Mustang\"!\n</code></pre>"},{"location":"tutorials/classConstructors/#class-destructors","title":"Class Destructors","text":"<p>A destructor is a special function that runs when you call <code>:Destroy()</code> on an object. To create a destructor, you have to specifically define a function called <code>destructor</code> outside of the Access Specifiers.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    constructor = function(self, brand, model, licensePlate)\n        self.License_Plate = licensePlate\n        self.Brand = brand\n        self.Model = model\n    end,\n    destructor = function(self)\n        self.License_Plate = \"\"\n        self.Brand = \"\"\n        self.Model = \"\"\n    end,\n    Public = {\n        Brand = \"\",\n        Model = \"\",\n        License_Plate = \"\"\n    },\n}\n\nlocal newCar = Car.new(\"ABCD\", \"Ford\", \"Mustang\")\nprint(newCar.Brand, newCar.Model, newCar.License_Plate)\n\nnewCar:Destroy() -- The class object will now be destroyed\nnewCar = nil\n</code></pre> <p>Info</p> <p>Unlike <code>constructor</code>, the <code>destructor</code> function does not take additional parameters, and the only argument will be the self pointing to the object. After the destructor is called, all the members inside the object will be set to nil (Instances inside are automatically destroyed and set to nil too), and the object will be locked, preventing any further access. At this stage, it would be best to set the object variable to nil, so the garbage collector can collect it and prevent memory leaks.</p> <p>Info</p> <p>Constructor and Destructor functions can also be written in the outside class definition syntax.</p>"},{"location":"tutorials/classCreation/","title":"Classes and Objects","text":"<p>A class is an user defined data structure. It's made out of members and member functions. Those members and member functions can be then accessed by creating an object from that class. Think of a class as a blueprint for an object.</p>"},{"location":"tutorials/classCreation/#creating-a-class","title":"Creating a Class","text":"<p>Here's an example of a person class:</p> <p><pre><code>local class = ClassPP.class\n\nlocal person = class \"Person\" {\n    Public = {\n        Name = \"\",\n        Age = 0\n    }\n}\n</code></pre> To create a new class, you use the <code>class()</code> function, with the above syntax, the first argument will be a string that defines the name of the class, and the second argument is the class data, a table that contains all the access specifiers and the member data.</p> <p>In the above example, we created a new class with the name <code>Person</code>, and we created two members, named: <code>Name</code> and <code>Age</code>.  Then, we assigned default values to them. These values will be transferred to the object when it gets created.</p>"},{"location":"tutorials/classCreation/#creating-an-object","title":"Creating an Object","text":"<p>Now that you have learned how to create classes, it's time to learn how to create objects. In Class++, to create an object you use the <code>class.new()</code> function. This function returns an object created from this class, and will contain all of the members that you defined.</p> <pre><code>local class = ClassPP.class\n\nlocal person = class \"Person\" {\n    Public = {\n        Name = \"\",\n        Age = 0\n    }\n}\n\nlocal newPerson = person.new()\nprint(newPerson.Age) -- Prints \"0\"!\n</code></pre> <p>Objects will have the members and their default values that you've set in the class data table, so if you want to update them, you can simply index the object with the member and set it to something else!</p> <pre><code>local class = ClassPP.class\n\nlocal person = class \"Person\" {\n    Public = {\n        Name = \"\",\n        Age = 0\n    }\n}\n\nlocal newPerson = person.new()\nnewPerson.Age = 21\n\nprint(newPerson.Age) -- Prints \"21\"!\n</code></pre> <p>Warning</p> <p>Unlike the classic class method on Roblox that developers use, in Class++, to define a member you must do it through the <code>class()</code> function, trying to define a new member through the object will result in an error.</p> <pre><code>local class = ClassPP.class\n\nlocal person = class \"Person\" {\n    Public = {\n        Name = \"\",\n        Age = 0\n    }\n}\n\nlocal newPerson = person.new()\nnewPerson.Personality = \"Cheerful\" -- This will error! This class has no member named \"Personality\".\n</code></pre>"},{"location":"tutorials/classMethods/","title":"Class Functions","text":"<p>Just like in C++, there are two ways to define a function(method) inside a class:</p> <ul> <li>Inside class definition</li> <li>Outside class definition</li> </ul>"},{"location":"tutorials/classMethods/#inside-class-definition","title":"Inside Class Definition","text":"<pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n        getLicensePlate = function(self)\n            print(self.License_Plate)\n        end\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n</code></pre> <p>In this example, we have defined a function inside the Public Access Specifier called <code>getLicensePlate</code>, this function when called will print the license plate of our object. </p> <p>Functions inside a class will always have <code>self</code> as their first argument. You can think of <code>self</code> as a pointer to the object. You can use it to access the object itself.</p> <p>Now, let's create an object from this class:</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n        getLicensePlate = function(self)\n            print(self.License_Plate)\n        end\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal newCar = Car.new()\nnewCar:getLicensePlate()\n</code></pre> <p>You can notice that instead of calling the function with <code>.</code> operator, we used <code>:</code> operator. This is because of the first argument always being <code>self</code>. Calling the function with a <code>.</code> operator will cause the <code>self</code> to not exist, so you must either call the function with the object as its first argument, or use <code>:</code> operator, as it makes it easier.</p>"},{"location":"tutorials/classMethods/#functions-with-multiple-parameters","title":"Functions with multiple parameters","text":"<pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n        getLicensePlate = function(self, number)\n            print(self.License_Plate, number) -- Prints \"XXXX 1\"!\n        end\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal newCar = Car.new()\nnewCar:getLicensePlate(1) -- Calling the function with an argument\n</code></pre> <p>Like in this example, you can call functions with multiple parameters.   Since <code>self</code> is the first argument, all the other arguments that come after will start at 2. This will be important in later pages.</p>"},{"location":"tutorials/classMethods/#outside-class-definition","title":"Outside Class Definition","text":"<p>To define a function outside of the class, you must define it as: <code>function Class.&lt;accessSpecifier&gt;:&lt;functionName&gt;</code></p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nfunction Car.Public:getLicensePlate(number)\n    print(self.License_Plate, number) -- Prints \"XXXX 1\"!\nend\n\nlocal newCar = Car.new()\nnewCar:getLicensePlate(1)\n</code></pre> <p>In this example, we defined a function outside of the class by specifying the class name, then the access specifier, followed by the <code>:</code> operator and the name of the function. Unlike in C++, you do not have to define the function first inside the class to use this method.</p> <p>Info</p> <p>Outside Class Definition syntax is recommended as it allows for a better formatting style.</p>"},{"location":"tutorials/errorHandling/","title":"Error Handling","text":"<p>In Class++, there are some errors to be cautious of. Some limitations exist, and when you encounter an error, Class++ will try to tell you what that happened. But sometimes that might not be enough, so this page serves as a tutorial on how to troubleshoot some very important errors that you might encounter.</p>"},{"location":"tutorials/errorHandling/#given-classdata-value-is-not-a-table-given-classdata-value-contains-a-metatable","title":"\"Given ClassData value is not a table.\" &amp; \"Given ClassData value contains a metatable.\"","text":"<p>When you're creating a class, always make sure that the top <code>classData</code> table that you're giving to the <code>class()</code> function is a raw table.  It must not contain a metatable, as classes are designed to be secure, adding a metatable to the <code>classData</code> will cause very important security problems. Attempting to give a value that's not a table or giving a table that contains a metatable will cause this error.</p>"},{"location":"tutorials/errorHandling/#cannot-redeclare-property","title":"\"Cannot redeclare property ...\"","text":"<p>This error was mentioned in one of the previous pages, but I think it needs some mention here. In Class++, access specifiers are not tables that you can declare the same member in. For example, let's say you created a member called <code>Name</code> in the <code>Public</code> access specifier, you cannot create <code>Name</code> again in the <code>Private</code> or <code>Protected</code> access specifiers. They're access specifiers after all, not different tables that you can use like this. Attempting to declare a member that's already been declared in an access specifier before will cause this error.</p>"},{"location":"tutorials/errorHandling/#a-function-to-handle-the-given-number-of-arguments-have-not-been-provided-for-the-overloaded-function","title":"\"A function to handle the given number of arguments ... have not been provided for the overloaded function: ...\"","text":"<p>This error occurs when you call an overloaded function with amount of arguments that do not correspond to a function in the given <code>functionTable</code>. For example, if you have an overloaded function, but do not have a specific function to handle 4 arguments, this error will occur.</p>"},{"location":"tutorials/errorHandling/#cannot-call-function-directly","title":"\"Cannot call function directly.\"","text":"<p>When you try to call a function inside a class directly, this error will occur. Classes are meant to be blueprints for an object, they cannot be used directly. Attempting to call a function inside a class and not through the object will cause this error.</p>"},{"location":"tutorials/friendAccessSpecifier/","title":"Friend Access Specifier","text":"<p>Friend access specifier allows anyone defined in that access specifier to access the private members of a class.</p> <p>Warning</p> <p>Members of this access specifier will not be replicated to objects, rather, these members are stored in the class itself, and they can only be used to access the members in other access specifiers through objects.</p> <pre><code>local function getLicensePlate(object: any)\n    print(object.License_Plate)\nend\n\nlocal class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    },\n    Friend = {\n        getLicensePlate\n    }\n}\n\nlocal newCar = Car.new()\ngetLicensePlate(newCar)\n</code></pre> <p>In this example, we updated the previous class to include a function in the <code>Friend</code> access specifier, this function is now able to access the private members of this class. </p> <p>Info</p> <p>Aside from functions, <code>Friend</code> access specifier can include other classes as well. Classes can be saved by using their variables, or their names. You can put a string inside the <code>Friend</code> access specifier that has the class's name, and it will still work!</p>"},{"location":"tutorials/functionOverloading/","title":"Function Overloading","text":"<p>Just like in many languages such as C++, Class++ supports function overloading.  Function Overloading is a feature where multiple functions can share the same name, but they are different from each other with different amount of arguments.</p> <p>To do function overloading in Class++, you have to use the <code>class.overload(&lt;accessSpecifier&gt;, &lt;name&gt;, &lt;functionTable&gt;)</code> function.</p> <pre><code>local class = ClassPP.class\n\nlocal Test = class \"Test\" {\n    Public = {\n        ValueA = 0,\n        ValueB = 0\n    }\n}\n\nTest.overload(\"Public\", \"Set\", {\n    function(self, a, b)\n        print(a, b)\n        self.ValueA = a\n        self.ValueB = b\n    end,\n    function(self, a)\n        print(a)\n        self.ValueA = a\n    end,\n    function(self)\n        print(self.ValueA, self.ValueB)\n    end\n})\n\nlocal newTest = Test.new()\nnewTest:Set(1, 2) -- Prints \"1 2\"\nnewTest:Set(3) -- Prints \"3\"\nnewTest:Set() -- Prints \"3 2\"\n</code></pre> <p>In this example, to create an overloaded function, we used the <code>.overload()</code> function with the <code>Public</code> access specifier, and <code>Set</code> for the function name. Then we gave a table with multiple functions with different arguments that each do a different thing. When we call the <code>:Set()</code> function through the object, depending on the amount of the given arguments, only the function that accepts the same amount of arguments will be ran.</p> <p>Warning</p> <p>Giving multiple functions that have the same amount of arguments will cause only one of these functions to be ran. Only create one function for a specific amount of arguments.</p>"},{"location":"tutorials/gettingStarted/","title":"Getting Started","text":"<p>Welcome to the tutorial section of Class++ !  Here, you will learn what you need to install Class++, how to install it, and how to create a basic testing script.</p>"},{"location":"tutorials/gettingStarted/#requirements","title":"Requirements","text":"<p>To use Class++, you don't need to be an expert developer, all you need is:</p> <ul> <li>Basic understanding on the concept of OOP (Object Oriented Programming), and Classes.</li> <li>Understanding on how metatables work in Roblox.</li> </ul> <p>Basically, if you're already experienced with OOP, you're good to go!  Especially, if you already have knowledge in languages like C++ and Java, your job will be pretty easy.</p>"},{"location":"tutorials/gettingStarted/#installation","title":"Installation","text":"<p>Installing Class++ is pretty easy! Just head over to this link to download the <code>ModuleScript</code>.</p> <p>After the download, open Roblox Studio, go into the place that you want to import Class++ to and right click on the <code>ReplicatedStorage</code> (or the location that you want to insert into), and select \"Insert from File\".</p> <p>Select the <code>Class++.rbxm</code> file that you just downloaded, and if the <code>ModuleScript</code> has appeared, congratulations, the Installation is complete!</p>"},{"location":"tutorials/gettingStarted/#creating-a-testing-script","title":"Creating A Testing Script","text":"<p>Now that you installed Class++, we can create a script to test if it has been successfully installed:</p> <ul> <li>1: Create a <code>Script</code> or a <code>LocalScript</code> instance, and parent it to <code>workspace</code> or <code>StarterPlayer &gt; StarterPlayerScripts</code>.</li> <li>2: Remove the <code>print(\"Hello World\")</code> line, and paste the following code in:</li> </ul> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal ClassPP = require(ReplicatedStorage[\"Class++\"])\nlocal class = ClassPP.class\n</code></pre> <ul> <li>3: Press \"Play\" or \"Run\". If everything is working properly and there are no errors, you're good to go!</li> </ul>"},{"location":"tutorials/inheritance/","title":"Inheritance","text":"<p>Just like in C++ and many other languages, Class++ allows you to inherit classes.  We group the inheritance concept into two categories: derived class (child), and the base class (parent).</p> <pre><code>local class = ClassPP.class\n\nlocal Vehicle = class \"Vehicle\" { -- Base Class\n    Public = {\n        Brand = \"Tesla\",\n        Model = \"S\",\n        License_Plate = \"BITE 1987\",\n        Year = 2012,\n        honk = function(self)\n            print(\"honk honk!\")\n        end\n    }\n}\n\nlocal Car = Vehicle.extends \"Car\" { -- Derived Class\n    Public = {\n        License_Plate = \"A1B2C3\"\n    }\n}\n\nlocal newCar = Car.new()\nnewCar:honk()\nprint(newCar.Brand, newCar.Model, newCar.License_Plate, newCar.Year) -- Prints \"Tesla S A1B2C3 2012\"!\n</code></pre> <p>In this example, we have 2 classes: The Vehicle class (base), and the Car class (child).  We create the Car class by calling the function <code>.extends()</code> on the Vehicle class, the <code>.extends()</code> function works almost the same as the <code>class</code> function, it takes in a name, and the class data. </p> <p>When you create a class using <code>.extends()</code>, you create a new derived class that inherits all of the members and member functions from the base class, so you don't need to re-declare them again. The members are overwritable in the derived class, like in the example above, you can modify the <code>License_Plate</code>'s default value to anything you wish. The same applies to other members.</p> <p>Question</p> <p>\"Why should I use Inheritence?\" It's very useful for code reusability: reusing members and functions of an existing class when you're creating a new class will save you a lot of time and effort, defining same members over and over again may cause spaghetti code and decrease code readability.</p>"},{"location":"tutorials/inheritance/#multilevel-inheritance","title":"Multilevel Inheritance","text":"<p>A class can also be derived from one class, which can be derived from another class:</p> <pre><code>local class = ClassPP.class\n\nlocal Person = class \"Person\" { -- Base Class\n    Public = {\n        Name = \"\",\n        Age = 0,\n        Gender = \"\",\n        Height = 0\n    }\n}\n\nlocal Child = Person.extends \"Child\" { -- Derived Class\n    Public = {\n        Age = 9,\n        Energetic = true\n    }\n}\n\nlocal Student = Child.extends \"Student\" { -- Derived Class from a Derived Class\n    Public = {\n        SchoolId = 0,\n        Grade = 0,\n        Behaviour = \"Good\"\n    }\n}\n\nlocal newStudent = Student.new()\nprint(newStudent.Name, newStudent.Age, newStudent.Gender, newStudent.Height, newStudent.Age, newStudent.Energetic, newStudent.SchoolId, newStudent.Grade, newStudent.Behaviour)\n-- Prints \" 9  0 9 true 0 0 Good\"! (Spaces represent empty strings)\n</code></pre>"},{"location":"tutorials/inheritance/#protected-access-specifier","title":"Protected Access Specifier","text":"<p>In the Access Specifiers section, you have learned that there are 4 access specifiers in Class++, so far you have seen <code>Public</code>, <code>Private</code> and <code>Friend</code>. The fourth specifier, <code>Protected</code>, is pretty much the same as the <code>Private</code>, however, aside from the class members, inherited classes will also be able to access these members. </p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Protected = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal BiggerCar = Car.extends \"BiggerCar\" {\n    Public = {\n        Brand = \"Tesla\"\n    }\n}\n\nfunction BiggerCar.Public:printLicensePlate()\n    print(self.License_Plate) -- Will print \"XXXX\"!\nend\n\nlocal newCar = BiggerCar.new()\nnewCar:printLicensePlate()\n</code></pre> <p>In this example, we put the member <code>License_Plate</code> under the <code>Protected</code> access specifier, and created a new class inherited from the Car class. The inherited class and it's member functions will now be able to access this member. </p>"},{"location":"tutorials/nonAccessSpecifiers/","title":"Non-Access Specifiers","text":"<p>Unlike access specifiers, non-access specifiers do not modify the access control of a member, but rather provide other functionality for classes.</p>"},{"location":"tutorials/nonAccessSpecifiers/#final","title":"Final","text":"<p>Using this non-access specifier will make the given class final, meaning this class now cannot be inherited by other classes.</p> <pre><code>local class, final = ClassPP.class, ClassPP.final\n\nlocal Car = final { class \"Car\" {\n    Public = {\n        Brand = \"Ford\",\n    }\n}}\n\nlocal BiggerCar = Car.extends \"BiggerCar\" { -- This will error!\n    Public = {\n        Brand = \"Tesla\"\n    }\n}\n</code></pre>"},{"location":"tutorials/nonAccessSpecifiers/#abstract","title":"Abstract","text":"<p>Using this non-access specifier will make the given class an abstract class, meaning this class now cannot be used to create objects. To access an abstract class, it must be inherited from another class.</p> <pre><code>local class, abstract = ClassPP.class, ClassPP.abstract\n\nlocal BaseCar = abstract { class \"BaseCar\" {\n    Public = {\n        Brand = \"\",\n        Model = \"\",\n        Year = 0,\n        honk = function(self)\n            print(\"honk honk!\")\n        end\n    }\n}}\n\nlocal Car = BaseCar.extends \"Car\" {\n    Public = {\n        Brand = \"Ford\",\n        Model = \"Mustang\",\n        Year = 2023\n    }\n}\n\nlocal newBaseCarObj = BaseCar.new() -- This will error!\nlocal newCarObj = Car.new() -- This will work fine!\nnewCarObj:honk()\n</code></pre> <p>Warning</p> <p>You cannot make a class both abstract and final, as they have opposite meanings. An abstract class must be subclassed, whereas a final class cannot be subclassed. Attempting to form an illegal combination between final and abstract methods will cause an error.</p>"},{"location":"tutorials/operatorOverloading/","title":"Operator Overloading","text":"<p>Suppose we have two objects that belong to a custom Vector class, how would we allow the addition of those two objects? Using normal class functions would be good, but it would take a longer time to write, and would be harder to understand.</p> <p>To solve this issue in Class++, just like in C++, we can change the way operators work for our classes. This is known as operator overloading.</p> <pre><code>local class = ClassPP.class\n\nlocal Vector = class \"Vector3\" {\n    constructor = function(self, x: number, y: number, z: number)\n        if typeof(x) ~= \"number\" or typeof(y) ~= \"number\" or typeof(z) ~= \"number\" then self.coordinates = {0, 0, 0} return end\n        self.coordinates = {x, y, z}\n    end,\n    Public = {\n        coordinates = {0, 0, 0},\n    },\n}\n\nfunction Vector.Public:operator_add(otherVector)\n    assert(#self.coordinates == #otherVector.coordinates)\n\n    local coordinates = {}\n\n    for i = 1, #self.coordinates do\n        coordinates[i] = self.coordinates[i] + otherVector.coordinates[i]\n    end\n\n    return Vector.new(coordinates[1], coordinates[2], coordinates[3])\nend\n\nfunction Vector.Public:__tostring()\n    return \"(\" .. table.concat(self.coordinates, \", \") .. \")\"\nend\n\nlocal vector1 = Vector.new(4, 5, 2)\nlocal vector2 = Vector.new(1, 2, 3)\n\nprint(vector1 + vector2) -- Prints \"(5, 7, 5)\"\n</code></pre> <p>In this example, we have created a custom Vector3 class that has a special function called <code>operator_add</code>, this special function is one of the special functions in Class++ that allows you to overload a specific operator. Here, we overloaded the operator <code>+</code> with our custom function that allows us to add two Vectors together.</p>"},{"location":"tutorials/operatorOverloading/#overloadable-operators","title":"Overloadable Operators","text":"Method Description <code>operator_add(self, obj)</code> Function for overloading the + operator. <code>operator_sub(self, obj)</code> Function for overloading the - operator. <code>operator_mul(self, obj)</code> Function for overloading the * operator. <code>operator_div(self, obj)</code> Function for overloading the / operator. <code>operator_idiv(self, obj)</code> Function for overloading the // operator. <code>operator_mod(self, obj)</code> Function for overloading the % operator. <code>operator_pow(self, obj)</code> Function for overloading the ^ operator. <code>operator_unm(self)</code> Function for overloading the unary \u2013 operator. <code>operator_eq(self, obj)</code> Function for overloading the == operator.\u00b9 <code>__tostring()</code> Fired when tostring is called on the object. <p>Info</p> <p>\u00b9: This function will only run when == operator is used with the same base type (table, userdata, etc.). It will not work with different types, such as an object with a table, or another type.</p> <p>Warning</p> <p>Trying to directly call the operator functions will result in an error. They must be called with their operators.</p>"},{"location":"tutorials/polymorphism/","title":"Polymorphism","text":"<p>In simple terms, Polymorphism stands for \"many forms\", it's one of the core concepts of OOP. It refers to situations where something occurs in several different forms, and describes the concept that you can access objects of different types through the same interface.</p> <p>Function Overloading, Operator Overloading, and Inheritance belong to this concept, for example with inheritance, we can create derived classes that have the same method name, but all do different things. Or with function overloading, every function has different arguments and does a different thing, but all share the same name. It provides flexibility, and extensibility.</p>"},{"location":"tutorials/polymorphism/#inheritance-example","title":"Inheritance Example","text":"<pre><code>local class = ClassPP.class\n\nlocal Animal = class \"Animal\" {\n    Public = {\n        animalSound = function(self)\n            print(\"The animal makes a sound\")\n        end\n    }\n}\n\n-- Derived class\nlocal Pig = Animal.extends \"Pig\" {\n    Public = {\n        animalSound = function(self)\n            print(\"The pig says: oink oink\")\n        end\n    }\n}\n\n-- Derived class\nlocal Dog = Animal.extends \"Dog\" {\n    Public = {\n        animalSound = function(self)\n            print(\"The dog says: woof woof\")\n        end\n    }\n}\n</code></pre>"},{"location":"tutorials/polymorphism/#function-overloading-example","title":"Function Overloading Example","text":"<pre><code>local class = ClassPP.class\n\nlocal Test = class \"Test\" {}\nTest.overload(\"Public\", \"Display\", {\n    function(self, number1)\n        print(\"Number: \", number1)\n    end,\n    function(self, number1, number2)\n        print(\"Numbers: \", number1, number2)\n    end\n})\n</code></pre>"},{"location":"tutorials/staticMembers/","title":"Static Members","text":"<p>Static members are members of the class that will exist regardless of whether or not any objects of the class are created. Once a static members has been created, they cannot be destroyed. Static members are also global, so all class objects have access to them, and their property will be the same across all of the objects.</p> <p>To create a static member in Class++, you have to use the <code>class.static(&lt;accessSpecifier&gt;, &lt;name&gt;, &lt;property&gt;)</code> function.</p> <pre><code>local class = ClassPP.class\n\nlocal Test = class \"Test\" {\n    Public = {\n        TestValue = 0\n    }\n}\n\nTest.static(\"Public\", \"StaticTestValue\", function(firstArgument)\n    print(firstArgument) -- This will not point to any object, instead it will print whatever it is called with! In this case, it will print \"Hi!\".\nend)\n\nlocal newTest = Test.new()\nnewTest:StaticTestValue() -- This will error!\n\nTest.StaticTestValue(\"Hi!\") -- This will work fine!\n</code></pre> <p>You can also give properties that aren't functions. So to retrieve those properties, you can do <code>class.&lt;memberName&gt;.property</code> or <code>class.&lt;memberName&gt;.p</code> for short.</p> <pre><code>local class = ClassPP.class\n\nlocal Test = class \"Test\" {\n    Public = {\n        TestValue = 0\n    }\n}\n\nTest.static(\"Public\", \"StaticTestValue\", 1)\n\nprint(Test.StaticTestValue.property) -- Prints \"1\"!\nprint(Test.StaticTestValue.p) -- Also prints \"1\"!\n</code></pre>"},{"location":"tutorials/types/","title":"Types","text":"<p>Currently, Class++ only supports automatic type completion to a limited extent, and requires custom types to be created to use all of the type completion features of Luau.</p> <pre><code>local Person = class \"Person\" {\n    Public = {\n        Age = 0,\n        Name = \"\",\n        Personality = \"\",\n        Likes = {},\n        Dislikes = {},\n        Job = \"\",\n        getSecrets = function(self: Person)\n            return self.Secrets\n        end,\n    },\n    Private = {\n        Secrets = {}\n    }\n}\n\nlocal newPerson = Person.new()\n-- This only supports auto-completion of the members in the Public access specifier!\n</code></pre> <p>If you want to create a class which supports all of the features of type completion in Luau, you have to create a custom type and assign it to the created objects. In the tutorial below, you will learn how to create a basic <code>Person</code> type and assign it to the created object to enable the support.</p>"},{"location":"tutorials/types/#creating-a-basic-custom-class-type","title":"Creating a Basic Custom Class Type","text":"<pre><code>local class = ClassPP.class\n\ntype Person = {\n    Age: number,\n    Name: string,\n    Personality: string,\n    Job: string,\n    Secrets: {string},\n    Likes: {string},\n    Dislikes: {string},\n    getSecrets: (self: Person) -&gt; {string}\n}\n\nlocal Person = class \"Person\" {\n    Public = {\n        Age = 0,\n        Name = \"\",\n        Personality = \"\",\n        Likes = {},\n        Dislikes = {},\n        Job = \"\",\n        getSecrets = function(self: Person)\n            return self.Secrets\n        end,\n    },\n    Private = {\n        Secrets = {}\n    }\n}\n\nlocal newPerson: Person = Person.new()\n-- This object now fully supports auto-completion!\n</code></pre> <p>In the example above, we created a custom type called <code>Person</code> for the Person class, and inserted the types of all the members inside it, and declared the new created object as of the Person type. This now allows us to use automatic type completion with our class objects.</p> <p>Info</p> <p>Since class objects belong to the base type <code>userdata</code>, you can type cast them to either your custom types, or any other existing type you wish.</p>"},{"location":"tutorials/types/#typechecking-for-classes-and-class-objects","title":"Typechecking for Classes and Class Objects","text":"<p>Class++ also comes with its own <code>Type</code> API that allows you to get the types of classes and class objects.</p> <pre><code>local class = ClassPP.class\nlocal ctypeof, typeofClass = ClassPP.Type.typeof, ClassPP.Type.typeofClass\n\ntype Person = {\n    Age: number,\n    Name: string,\n    Personality: string,\n    Job: string,\n    Secrets: {string},\n    Likes: {string},\n    Dislikes: {string},\n    getSecrets: (self: Person) -&gt; {string}\n}\n\nlocal Person = class \"Person\" {\n    Public = {\n        Age = 0,\n        Name = \"\",\n        Personality = \"\",\n        Likes = {},\n        Dislikes = {},\n        Job = \"\",\n        getSecrets = function(self: Person)\n            return self.Secrets\n        end,\n    },\n    Private = {\n        Secrets = {}\n    }\n}\n\nlocal newPerson: Person = Person.new()\nprint(ctypeof(Person), \",\", ctypeof(newPerson)) -- Prints \"Class , Person\"!\n</code></pre>"},{"location":"tutorials/types/#typetypeof","title":"Type.typeof","text":"<p><code>Type.typeof</code> will return the true type of the given object. For example, if the object is a <code>class</code>, it will return \"Class\", as it belongs to the <code>Class</code> type. And if the object is a class <code>object</code>, it will return the name of the <code>class</code> it's been created from as its type.</p>"},{"location":"tutorials/types/#typetypeofclass","title":"Type.typeofClass","text":"<p>In Class++, like in languages such as C++ and Java, classes are also types on their own. Their true type will always belong to the <code>Class</code> type, however, they can also be represented as types.</p> <p>So to make this possible, the <code>Type</code> API provides a function to get the type a <code>class</code> is, called: <code>Type.typeofClass</code>.</p> <p>Using this function, you can get the types of classes and compare and use them however you wish.</p> <p>Warning</p> <p>Using the <code>class.Name</code> property may create bugs in certain places as the Type API makes sure the given object is an actual class object before returning its type. It's recommended that you use the Type API instead of the <code>.Name</code> property.</p>"}]}