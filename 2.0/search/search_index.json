{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#classppTitle","title":"Overload your Classes.","text":"<p>     Tired of the traditional class system on Roblox?     Tired of learning complex systems, and wish for something easier?     Wish to do OOP in the right way, like in many languages such as C++? </p> <p>     Then you're in the right place.     Introducing: Class++.     Classes were never this easy to create, and advanced before on Roblox. </p> Getting Started Download"},{"location":"api-reference/","title":"API Reference","text":"<p>Welcome to the API Reference section of Class++ !  This section is more technical, and is not recommended for beginners. Check out the tutorials for a guided experience!</p> <p>You can use the left bar to find the API members grouped by their category. Additionally, you can use the search bar to find a specific API member.</p>"},{"location":"api-reference/errors/","title":"Errors","text":"<p>When Class++ displays an error message to the output, it will have a short ID at the end. This allows you to identify what kind of error or message that is.</p> <p>You can use that ID to find the details about that error or message down below.</p>"},{"location":"api-reference/errors/#attempttomodifyreadonlytable","title":"attemptToModifyReadOnlyTable","text":"<pre><code>Cannot modify a read only table.\n</code></pre> <p>You've attempted modify a read-only table within Class++. This usually occurs when you try to modify the <code>Inherits</code>, <code>Friends</code> and <code>Statics</code> tables of a <code>class</code>.</p>"},{"location":"api-reference/errors/#attempttocreateobjectfromabstractclass","title":"attemptToCreateObjectFromAbstractClass","text":"<pre><code>Cannot create an object from an abstracted class.\n</code></pre> <p>You tried to create an <code>object</code> from an abstract <code>class</code>. Abstract classes are not meant to create objects from, rather, they are meant to be a base-class that a <code>class</code> inherits from.</p>"},{"location":"api-reference/errors/#attempttoextendafinalclass","title":"attemptToExtendAFinalClass","text":"<pre><code>Cannot create an inherited class from a final class.\n</code></pre> <p>You tried to create a <code>class</code> from a final <code>class</code>. Final classes are not meant to be inherited from.</p>"},{"location":"api-reference/errors/#cannotcallfunctionerror","title":"cannotCallFunctionError","text":"<pre><code>Cannot call function ... directly.\n</code></pre> <p>You've tried to call a function within a <code>class</code> without creating an <code>object</code>. Class functions are not meant to be used directly, rather, they are to be used from objects. (Excluding static members.)</p>"},{"location":"api-reference/errors/#cannotcallfunctionfrom","title":"cannotCallFunctionFrom","text":"<pre><code>Cannot call function ... from ...\n</code></pre> <p>You've tried to call a function within an <code>object</code> that cannot be called within certain functions, such as <code>super()</code> in <code>destructor</code>.</p>"},{"location":"api-reference/errors/#cannotfindbaseclassmethod","title":"cannotFindBaseClassMethod","text":"<pre><code>Property ... cannot be found or is not a function in the base class ...\n</code></pre> <p>You've tried to call a property with <code>super()</code> in the base <code>class</code> that cannot be found, or wasn't a function.</p>"},{"location":"api-reference/errors/#classalreadyexists","title":"classAlreadyExists","text":"<pre><code>Class ... already exists.\n</code></pre> <p>You've tried to create a <code>class</code> that already has been created with the same name. Consider changing the name of the new <code>class</code>.</p>"},{"location":"api-reference/errors/#classclassdatainternal","title":"classClassDataInternal","text":"<pre><code>The property classData of the class ... is Internal. It cannot be used.\n</code></pre> <p>You've attempted to access the <code>classData</code> property of a <code>class</code> directly. This property is meant to be used internally, and is not meant for external use. This property only shows up in the auto-complete to support type-checking in certain cases.</p>"},{"location":"api-reference/errors/#classdatanottable","title":"classDataNotTable","text":"<pre><code>Given classData value for the class ... is not a table.\n</code></pre> <p>You've given a <code>classData</code> value that is not a table to the <code>class</code> function. The <code>class</code> function only takes a table as its <code>classData</code> parameter.</p>"},{"location":"api-reference/errors/#classdatacontainsmetatable","title":"classDataContainsMetatable","text":"<pre><code>Given classData value for the class ... contains a metatable.\n</code></pre> <p>You've given a <code>classData</code> value that contains a metatable attached to it. For security and performance reasons, <code>classData</code> parameter only takes a raw table without any metatables attached to it.</p>"},{"location":"api-reference/errors/#classmembercannotsettonil","title":"classMemberCannotSetToNil","text":"<pre><code>Class members cannot be set to nil.\n</code></pre> <p>You've attempted to set a class member within the <code>object</code> to nil. Setting member values to nil causes certain bugs to happen (due to the nature of dictionaries), so it is not allowed to set them to <code>nil.</code> Consider setting it to a value such as <code>false</code> to indicate that it is no longer in use.</p>"},{"location":"api-reference/errors/#classmembernotfound","title":"classMemberNotFound","text":"<pre><code>This class has no member named ...\n</code></pre> <p>You've tried to index the <code>object</code> with a member that does not exist within the <code>classData</code> table. Members can only be added or removed through changing the <code>classData</code> table given to the <code>class</code> function.</p>"},{"location":"api-reference/errors/#classnamenotstring","title":"classNameNotString","text":"<pre><code>Class name is not a string or is nil.\n</code></pre> <p>The <code>class</code> function expected a <code>string</code> as it's name, but you provided something else. A <code>class</code>'s name can only be a <code>string</code>. </p>"},{"location":"api-reference/errors/#classnotfound","title":"classNotFound","text":"<pre><code>A class with the given name cannot be found.\n</code></pre> <p>A <code>class</code> cannot be found with the provided name argument. Make sure the name is correct, or if the <code>class</code> actually exists.</p>"},{"location":"api-reference/errors/#classnomatchingfunctionerror","title":"classNoMatchingFunctionError","text":"<pre><code>No match for ... function in this class.\n</code></pre> <p>You've used an operator on an <code>object</code> which had no overloads set for it.</p>"},{"location":"api-reference/errors/#classobjectlocked","title":"classObjectLocked","text":"<pre><code>This class object has been locked.\n</code></pre> <p>You've tried to use an <code>object</code> after it's been locked.</p>"},{"location":"api-reference/errors/#classpropertyisprivate","title":"classPropertyIsPrivate","text":"<pre><code>Property ... is private in this class.\n</code></pre> <p>You've tried to access a private member of an <code>object</code> outside of a class function.</p>"},{"location":"api-reference/errors/#classpropertyisprotected","title":"classPropertyIsProtected","text":"<pre><code>Property ... is protected in this class.\n</code></pre> <p>You've tried to access a protected member of an <code>object</code> outside of a class function.</p>"},{"location":"api-reference/errors/#classpropertyisinternal","title":"classPropertyIsInternal","text":"<pre><code>Property ... is internal in this class. You cannot access it.\n</code></pre> <p>You've tried to access an internal member of an <code>object</code>. Internal members are not accessible.</p>"},{"location":"api-reference/errors/#classpropertyredeclaration","title":"classPropertyRedeclaration","text":"<pre><code>Cannot redeclare property ...\n</code></pre> <p>You've tried to declare a property that has already been declared in another access-specifier. You can only declare a member in one access-specifier.</p>"},{"location":"api-reference/errors/#expectedfunctionerror","title":"expectedFunctionError","text":"<pre><code>Expected function, got: ...\n</code></pre> <p>The <code>functionsTable</code> that you provided to <code>class.overload</code> function had a value that wasn't a function.</p>"},{"location":"api-reference/errors/#extendsdeprecated","title":"extendsDeprecated","text":"<pre><code>Extends is now deprecated. Use the \"class\" function instead.\n</code></pre> <p>You've tried to use the now deprecated <code>extends</code> function for inheritance. See the discussion <code>#4</code> for more info.</p>"},{"location":"api-reference/errors/#invalidaccessspecifiererror","title":"invalidAccessSpecifierError","text":"<pre><code>Given value is not a valid access specifier.\n</code></pre> <p>You've provided a value that wasn't a valid access specifier. Make sure the given <code>string</code> contains a valid access-specifier. </p>"},{"location":"api-reference/errors/#invalidaccessspecifierinclassdata","title":"invalidAccessSpecifierInClassData","text":"<pre><code>Given classData value for the class ... contains invalid access specifier(s) or function(s).\n</code></pre> <p>You've given a <code>classData</code> value that contains invalid access-specifiers or functions. Make sure the access-specifier or function names are correct.</p>"},{"location":"api-reference/errors/#invaliddestructorcall","title":"invalidDestructorCall","text":"<pre><code>Cannot call Destroy without an object argument. Try calling the function with the ':' operator.\n</code></pre> <p>You've tried to call the <code>Destroy()</code> without providing the <code>object</code> as its first argument. Calling it with a ':' like <code>:Destroy()</code>, passes the <code>object</code> argument automatically.</p>"},{"location":"api-reference/errors/#invalidmodifierargument","title":"invalidModifierArgument","text":"<pre><code>Given argument is not a class table.\n</code></pre> <p>You've given a value to a modifier function that wasn't a table containing classes.</p>"},{"location":"api-reference/errors/#invalidpropertydecleration","title":"invalidPropertyDecleration","text":"<pre><code>Cannot create reserved property ...\n</code></pre> <p>You've tried to create a reserved property in a <code>class</code>. Some property names are reserved for certain functions that come by default for every <code>object</code>, so you cannot declare them inside the <code>classData</code> value.</p>"},{"location":"api-reference/errors/#invalidsupercall","title":"invalidSuperCall","text":"<pre><code>Cannot call super in a multi-inherited class, or in a non-inherited class.\n</code></pre> <p>You've tried to call the <code>super()</code> function from a <code>class</code> that either wasn't inheriting from another <code>class</code>, or it was inheriting from multiple <code>class</code>es. </p>"},{"location":"api-reference/errors/#illegalmodifiercombination","title":"illegalModifierCombination","text":"<pre><code>Cannot create an illegal combination of modifiers: ...\n</code></pre> <p>You've tried to create an illegal combination of modifiers. Certain modifiers have opposite functionality, so combining them is not possible.</p>"},{"location":"api-reference/errors/#nonnativeoperatorcall","title":"nonNativeOperatorCall","text":"<pre><code>Operator function ... cannot be called without its operator.\n</code></pre> <p>You've tried to call an operator function without its operator. Operator functions are meant to be called with their operators.</p>"},{"location":"api-reference/errors/#overloadfunctionargumentmismatch","title":"overloadfunctionArgumentMismatch","text":"<pre><code>A function to handle the given number of arguments ... have not been provided for the overloaded function: ...\n</code></pre> <p>You haven't provided a function to the <code>functionsTable</code> to handle the given number of arguments for an overloaded function.</p>"},{"location":"api-reference/errors/#overloadfunctionnamenotset","title":"overloadfunctionNameNotSet","text":"<pre><code>A function name has not been set for the overloaded function.\n</code></pre> <p>You haven't provided a name for the overloaded function.</p>"},{"location":"api-reference/errors/#overloadfunctiontablenotgiven","title":"overloadfunctionTableNotGiven","text":"<pre><code>A function table has not been given for the overloaded function.\n</code></pre> <p>You haven't provided a <code>functionsTable</code> for the overloaded function.</p>"},{"location":"api-reference/errors/#staticmembernamenotset","title":"staticMemberNameNotSet","text":"<pre><code>A name has not been set for the static member.\n</code></pre> <p>You haven't provided a name for the static member.</p>"},{"location":"api-reference/errors/#typeofobjectnotfound","title":"typeofObjectNotFound","text":"<pre><code>The given object's type cannot be found.\n</code></pre> <p>The provided object's type cannot be found.</p>"},{"location":"api-reference/errors/#unknownerror","title":"unknownError","text":"<pre><code>An unknown error has occured.\n</code></pre> <p>Class++ ran into a problem, but it cannot associate it with a valid error type. This is meant to be a fallback error, and may only occur if the internal code isn't running properly.</p>"},{"location":"api-reference/class-functions/main/abstract/","title":"abstract :class","text":"<p><pre><code>function classpp.abstract(classTable: {class}): class\n</code></pre> Marks the given <code>class</code> or <code>class</code>es as abstract. If given multiple, then the first class will be returned.</p>"},{"location":"api-reference/class-functions/main/abstract/#default-syntax","title":"Default Syntax","text":"<pre><code>local Car = abstract { class \"Car\" {\n    Public = {\n        ...\n    },\n    ...\n}}\n</code></pre>"},{"location":"api-reference/class-functions/main/abstract/#without-syntax-sugar","title":"Without Syntax Sugar","text":"<pre><code>local Car = abstract({class(\"Car\")({\n    Public = {\n        ...\n    },\n    ...\n})})\n</code></pre>"},{"location":"api-reference/class-functions/main/abstract/#parameters","title":"Parameters","text":"<p> classTable: {class} The desired <code>class</code> or <code>class</code>es to be set to abstract. </p>"},{"location":"api-reference/class-functions/main/abstract/#returns","title":"Returns","text":"<p> class"},{"location":"api-reference/class-functions/main/class/","title":"class :class","text":"<pre><code>function classpp.class(className: string): (classData: classData) -&gt; class\n</code></pre> <p>Creates a new <code>class</code> with the given <code>classData</code> table.</p>"},{"location":"api-reference/class-functions/main/class/#default-syntax","title":"Default Syntax","text":"<pre><code>local Class = class \"Class\" {\n    constructor = function(self)\n        ...\n    end,\n    destructor = function(self)\n        ...\n    end,\n    Public = {\n        ...\n    },\n    Private = {\n        ...\n    },\n    Protected = {\n        ...\n    },\n    Friend = {\n        ...\n    }\n}\n</code></pre>"},{"location":"api-reference/class-functions/main/class/#without-syntax-sugar","title":"Without Syntax Sugar","text":"<pre><code>local Class = class(\"Class\")({\n    constructor = function(self)\n        ...\n    end,\n    destructor = function(self)\n        ...\n    end,\n    Public = {\n        ...\n    },\n    Private = {\n        ...\n    },\n    Protected = {\n        ...\n    },\n    Friend = {\n        ...\n    }\n})\n</code></pre>"},{"location":"api-reference/class-functions/main/class/#parameters","title":"Parameters","text":"<p> className: string An unique name for the <code>class</code>. inheritedClasses: ...class The <code>class</code>es the created <code>class</code> will inherit from. (Optional) classData: classData The <code>classData</code> table that contains the data such as access specifiers for the <code>class</code>."},{"location":"api-reference/class-functions/main/class/#returns","title":"Returns","text":"<p> class"},{"location":"api-reference/class-functions/main/final/","title":"final :class","text":"<pre><code>function classpp.final(classTable: {class}): class\n</code></pre> <p>Marks the given <code>class</code> or <code>class</code>es as final. If given multiple, then the first class will be returned.</p>"},{"location":"api-reference/class-functions/main/final/#default-syntax","title":"Default Syntax","text":"<pre><code>local Car = final { class \"Car\" {\n    Public = {\n        ...\n    },\n    ...\n}}\n</code></pre>"},{"location":"api-reference/class-functions/main/final/#without-syntax-sugar","title":"Without Syntax Sugar","text":"<pre><code>local Car = final({class(\"Car\")({\n    Public = {\n        ...\n    },\n    ...\n})})\n</code></pre>"},{"location":"api-reference/class-functions/main/final/#parameters","title":"Parameters","text":"<p> classTable: {class} The desired <code>class</code> or <code>class</code>es to be set to final. </p>"},{"location":"api-reference/class-functions/main/final/#returns","title":"Returns","text":"<p> class"},{"location":"api-reference/class-functions/main/getClass/","title":"getClass :class","text":"<pre><code>function classpp.getClass(className: string): class\n</code></pre> <p>Returns the <code>class</code> with the given <code>className</code>, if it exists.</p>"},{"location":"api-reference/class-functions/main/getClass/#default-syntax","title":"Default syntax","text":"<pre><code>local Class = ClassPP.getClass(\"Class\")\n</code></pre>"},{"location":"api-reference/class-functions/main/getClass/#parameters","title":"Parameters","text":"<p> className: string The name of the desired <code>class</code>. </p>"},{"location":"api-reference/class-functions/main/getClass/#returns","title":"Returns","text":"<p> class"},{"location":"api-reference/class-functions/type/type/","title":"type :string","text":"<pre><code>function Type.type(object: any): string\n</code></pre> <p>Returns the true type of the given <code>object</code>. Behaves the same as the built-in <code>type()</code> function, but with additional support for <code>class</code>es and <code>object</code>s.</p>"},{"location":"api-reference/class-functions/type/type/#default-syntax","title":"Default syntax","text":"<pre><code>local objectType = ClassPP.Type.type(object)\n</code></pre>"},{"location":"api-reference/class-functions/type/type/#parameters","title":"Parameters","text":"<p> object: object The <code>object</code>. </p>"},{"location":"api-reference/class-functions/type/type/#returns","title":"Returns","text":"<p> string"},{"location":"api-reference/class-functions/type/typeof/","title":"typeof :string","text":"<pre><code>function Type.typeof(object: any): string\n</code></pre> <p>Returns the type of the given <code>object</code>. Behaves the same as the built-in Roblox <code>typeof()</code> function, but with additional support for <code>class</code>es and <code>object</code>s.</p>"},{"location":"api-reference/class-functions/type/typeof/#default-syntax","title":"Default syntax","text":"<pre><code>local objectType = ClassPP.Type.typeof(object)\n</code></pre>"},{"location":"api-reference/class-functions/type/typeof/#parameters","title":"Parameters","text":"<p> object: object The <code>object</code>. </p>"},{"location":"api-reference/class-functions/type/typeof/#returns","title":"Returns","text":"<p> string"},{"location":"api-reference/class-functions/utility/checkFriendship/","title":"checkFriendship :boolean","text":"<pre><code>function Util.checkFriendship(class: class, methodName: string, method: () -&gt; (), classes: {[string]: class}): boolean\n</code></pre> <p>This function checks if the given <code>method</code> and it's <code>methodName</code> is in the given <code>class</code>'s <code>Friend</code> access specifier.</p>"},{"location":"api-reference/class-functions/utility/checkFriendship/#default-syntax","title":"Default syntax","text":"<pre><code>local isAFriend = ClassPP.Util.checkFriendship(class, methodName, method, classes)\n</code></pre>"},{"location":"api-reference/class-functions/utility/checkFriendship/#parameters","title":"Parameters","text":"<p> class: class The <code>class</code> that the check will be made from. methodName: string The name of the given <code>method</code>. class: class The <code>method</code> that will be checked. classes: {[string]: class} A table that contains all of the created <code>class</code>es. Since a <code>class</code> can also be inserted to the <code>Friend</code> access specifier through a <code>string</code> that contains the <code>class</code>'s name, this table is used to find the <code>class</code>es set with this method. </p>"},{"location":"api-reference/class-functions/utility/checkFriendship/#returns","title":"Returns","text":"<p> boolean"},{"location":"api-reference/class-functions/utility/checkInheritance/","title":"checkInheritance :boolean","text":"<pre><code>function Util.checkInheritance(class: class, classOrMethod: class | () -&gt; ()): boolean\n</code></pre> <p>If the <code>classOrMethod</code> is a <code>class</code>, the function checks if the given <code>class</code> has been inherited from <code>classOrMethod</code>, or if the <code>classOrMethod</code> is a method, then it simply checks if any of the classes that the given <code>class</code> inherits from contains the method.</p>"},{"location":"api-reference/class-functions/utility/checkInheritance/#default-syntax","title":"Default syntax","text":"<pre><code>local isInherited = ClassPP.Util.checkInheritance(classOne, classTwo) -- For classes\nlocal isInherited = ClassPP.Util.checkInheritance(class, method) -- For methods\n</code></pre>"},{"location":"api-reference/class-functions/utility/checkInheritance/#parameters","title":"Parameters","text":"<p> class: class The <code>class</code> that the check will be made from. classOrMethod: class | () -&gt;() The <code>class</code> or the <code>method</code> that will be checked. </p>"},{"location":"api-reference/class-functions/utility/checkInheritance/#returns","title":"Returns","text":"<p> boolean"},{"location":"api-reference/class-functions/utility/inClassScope/","title":"inClassScope :boolean","text":"<pre><code>function Util.inClassScope(class: class, includeInherited: boolean, includeFriend: boolean, classes: {[string]: class}?, defaultLevel: number?): boolean\n</code></pre> <p>This function checks if the current thread is allowed to access a specific <code>class</code> property from a certain access specifier.</p>"},{"location":"api-reference/class-functions/utility/inClassScope/#default-syntax","title":"Default syntax","text":"<pre><code>local isAllowed = Util.inClassScope(class, false, true, Classes) -- For the Private access specifier\n</code></pre>"},{"location":"api-reference/class-functions/utility/inClassScope/#parameters","title":"Parameters","text":"<p> class: class The <code>class</code> that the check will be made from. includeInherited: boolean Determines if the inherited <code>class</code>es can access. includeFriend: boolean Determines if the friend <code>class</code>es can access. classes: {[string]: class} A table that contains classes. If <code>includeFriend</code> is set to <code>true</code>, this table will be given to the Util.checkFriendship function. defaultLevel: number Determines the default call stack level the function will start doing the checks on. </p>"},{"location":"api-reference/class-functions/utility/inClassScope/#returns","title":"Returns","text":"<p> boolean"},{"location":"api-reference/data-types/class/","title":"Class","text":"<p>A <code>class</code> object created from the <code>class()</code> function. Contains all of the members given from the <code>classData</code>.</p> Summary Properties <ul> <li>Name: An unique identifier of the <code>class</code>.</li> <li>Inherits: A table that contains classes that the <code>class</code> inherits from.</li> <li>Friends: A table that contains functions or clases that can access the <code>Private</code> and the <code>Protected</code> members of the <code>class</code>. </li> <li>Statics:  A table that contains the static members of the <code>class</code>. These members can only be called through the <code>class</code> object.</li> </ul> Methods <ul> <li>new:  Returns a new <code>object</code> that contains all of the members given from the <code>class</code>.</li> <li>extends: Used to create a new <code>class</code> that inherits the <code>class</code> it's been created from. (Deprecated)</li> <li>overload: Creates an overloaded function with the given access specifier, name and the function table, and saves it to the <code>class</code>'s <code>classData</code>.</li> </ul>"},{"location":"api-reference/data-types/class/#properties","title":"Properties","text":""},{"location":"api-reference/data-types/class/#name-string","title":"Name              : string","text":"<p>This is an unique identifier of the <code>class</code>. Using the <code>getClass()</code> function with this property will retrieve the desired <code>class</code>. Since names are unique, for every class, you have to use a different name.</p>"},{"location":"api-reference/data-types/class/#inherits-class-read-only","title":"Inherits              : {class}      Read Only","text":"<p>This table contains all the classes that the <code>class</code> is inheriting from. </p>"},{"location":"api-reference/data-types/class/#friends-class-read-only","title":"Friends              : {class}      Read Only","text":"<p>This table contains all the functions and the classes that can access all of the <code>Public</code> and <code>Protected</code> members of the <code>class</code>.</p>"},{"location":"api-reference/data-types/class/#statics-string-any-read-only","title":"Statics              : {[string]: any}      Read Only","text":"<p>This table contains all the members that are static, meaning they only belong to the <code>class</code>. These members won't replicate to the  objects, and can only be called through the <code>class</code> object.</p>"},{"location":"api-reference/data-types/class/#methods","title":"Methods","text":""},{"location":"api-reference/data-types/class/#new-object","title":"new              : object","text":"<p>Creates and returns a new <code>object</code> that contains all of the members given from the <code>class</code>.</p>"},{"location":"api-reference/data-types/class/#returns","title":"Returns","text":"<p> object </p>"},{"location":"api-reference/data-types/class/#extends-void","title":"extends              : void","text":"<p>Used to create and return a new <code>class</code> that inherits the <code>class</code> it's been created from.</p> <p>Deprecated</p> <p>This method has been deprecated and should not be used for new work. Instead, use the <code>class</code> method.</p>"},{"location":"api-reference/data-types/class/#overload-void","title":"overload              : void","text":"<p>Creates an overloaded function with the given parameters, and saves it to the <code>class</code>'s <code>classData</code> table.</p>"},{"location":"api-reference/data-types/class/#parameters","title":"Parameters","text":"<p> accessSpecifier: string The access specifier of the overloaded function. name: string The name of the overloaded function. functionTable: {(...any) -&gt; (any)} The function table that contains all the functions with different amount of arguments for the overloaded function. </p>"},{"location":"api-reference/data-types/class/#returns_1","title":"Returns","text":"<p> void </p>"},{"location":"api-reference/data-types/class/#static-void","title":"static              : void","text":"<p>Creates a new static member with the given parameters, and saves it to the <code>class</code>'s <code>Statics</code> table. These members do not replicate to the objects, as they belong to the <code>class</code>. </p>"},{"location":"api-reference/data-types/class/#parameters_1","title":"Parameters","text":"<p> accessSpecifier: string The access specifier of the static member. name: string The name of the static member. property: any The property that will be saved to the static member. This property can then be accessed through indexing the <code>class</code> with the member name, such as: <code>class.memberName.property</code>. (Or <code>class.memberName.p</code>) </p>"},{"location":"api-reference/data-types/class/#returns_2","title":"Returns","text":"<p> void </p>"},{"location":"api-reference/data-types/object/","title":"Object","text":"<p>An <code>object</code> created from the <code>class.new()</code> function. Contains all of the members given from the <code>class</code> object.</p> <p>Warning</p> <p><code>object</code>s act as a proxy, as they belong to the base type <code>userdata</code>. They allow access to members in the <code>objectData</code>, but they cannot be changed. This is to make access-specifiers work in the best way possible.</p> Summary Properties <ul> <li>__locked: Indicates if the <code>object</code> is locked.</li> <li>__type: Indicates the type of the <code>object</code>.</li> <li>__objtype: Indicates the <code>class</code> type of the <code>object</code>.</li> </ul> Methods <ul> <li>constructor: The constructor function of the <code>object</code>, if it exists. Cannot be directly called.</li> <li>destructor: The destructor function of the <code>object</code>, if it exists. Cannot be directly called.</li> <li>Destroy: Calls the <code>destructor</code> function, destroys all the instances inside the <code>objectData</code> and clears it, and sets the <code>__locked</code> property to <code>true</code>.</li> <li>super: Calls the method with the same name of the function that it's been called from in the parent <code>class</code>, if it exists.</li> </ul>"},{"location":"api-reference/data-types/object/#properties","title":"Properties","text":""},{"location":"api-reference/data-types/object/#__locked-boolean-internal","title":"__locked              : boolean      Internal","text":"<p>Indicates if an <code>object</code> has been locked. If set to true, the <code>object</code>'s metamethods will no longer work and all the members will become unaccessable. </p>"},{"location":"api-reference/data-types/object/#__type-string-internal","title":"__type              : string      Internal","text":"<p>Indicates the type of the <code>object</code>. For <code>object</code>s created from <code>class.new()</code>, it will always be \"Object\".</p>"},{"location":"api-reference/data-types/object/#__objtype-string-internal","title":"__objtype              : string      Internal","text":"<p>Indicates the <code>class</code> type of the <code>object</code>. Can be used to determine which <code>class</code> the <code>object</code> belongs to by using the <code>Type.typeof()</code> function.</p>"},{"location":"api-reference/data-types/object/#methods","title":"Methods","text":""},{"location":"api-reference/data-types/object/#constructor-void-internal","title":"constructor              : void      Internal","text":"<p>The <code>constructor</code> function of the <code>object</code>, if it has been set in the <code>classData</code> table. This function is internal, and it will only be called when the <code>object</code> is created by using the <code>class.new()</code> function.</p>"},{"location":"api-reference/data-types/object/#returns","title":"Returns","text":"<p> void </p>"},{"location":"api-reference/data-types/object/#destructor-void-internal","title":"destructor              : void      Internal","text":"<p>The <code>destructor</code> function of the <code>object</code>, if it has been set in the <code>classData</code> table. This function accepts no parameters and is internal, it will only be called when <code>object:Destroy()</code> is called. </p>"},{"location":"api-reference/data-types/object/#returns_1","title":"Returns","text":"<p> void </p>"},{"location":"api-reference/data-types/object/#destroy-void","title":"Destroy              : void","text":"<p>Calling this method will destroy and clean the <code>object</code>. This method will first trigger the <code>destructor</code> function, then after, it will clear the internal <code>objectData</code> table and set the <code>__locked</code> property of the <code>object</code> to <code>true</code>. Instances inside <code>objectData</code> will automatically be destroyed and cleared too.</p> <p>After this function runs, the <code>object</code> will no longer be accessible in any way, so make sure to remove all references to the <code>object</code> to allow for the garbage collector to clear it. This prevents memory leaks.</p>"},{"location":"api-reference/data-types/object/#returns_2","title":"Returns","text":"<p> void </p>"},{"location":"api-reference/data-types/object/#super-any","title":"super              : any","text":"<p>This method allows you to refer to the parent <code>class</code>'s methods. Calling this method will call the function with the same name as the function it's been called from in the parent <code>class</code>, if it exists, and return the result.</p> <p>Warning</p> <p><code>super</code> does not support being called in <code>class</code>es created from multi-inheritance, as it would create ambiguity. It also does not support calling functions that are defined in the <code>Private</code> access-specifier in the parent <code>class</code>.</p>"},{"location":"api-reference/types/classData/","title":"classData","text":"<pre><code>export type classData = {\n    constructor: (self: any, ...any) -&gt; ()?,\n    destructor: (self: any) -&gt; ()?,\n    Public: {[string]: any}?,\n    Private: {[string]: any}?,\n    Protected: {[string]: any}?,\n    Friend: {any}?\n}\n</code></pre> <p>The <code>classData</code> table that is given to the <code>class()</code> function that contains data about the desired <code>class</code>.</p>"},{"location":"api-reference/types/classData/#properties","title":"Properties","text":""},{"location":"api-reference/types/classData/#constructor-self-any-any-","title":"constructor              : (self: any, ...any) -&gt; ()?","text":"<p>The <code>constructor</code> function that will be called when an <code>object</code> gets created.</p>"},{"location":"api-reference/types/classData/#destructor-self-any-","title":"destructor              : (self: any) -&gt; ()?","text":"<p>The <code>destructor</code> function that will be called when an <code>object</code> gets destroyed.</p>"},{"location":"api-reference/types/classData/#public-string-any","title":"Public              : {[string]: any}?","text":"<p>The access specifier that contains properties that can be globally accessable.</p>"},{"location":"api-reference/types/classData/#private-string-any","title":"Private              : {[string]: any}?","text":"<p>The access specifier that contains properties that can only be accessed inside the <code>class</code>.</p>"},{"location":"api-reference/types/classData/#protected-string-any","title":"Protected              : {[string]: any}?","text":"<p>The access specifier that contains properties that can only be accessed inside the <code>class</code> and inherited classes.</p>"},{"location":"api-reference/types/classData/#friend-any","title":"Friend              : {any}?","text":"<p>The access specifier that contains functions and classes that can access the <code>class</code>'s <code>Private</code> properties.</p>"},{"location":"tutorials/","title":"Getting Started","text":"<p>Welcome to the tutorial section of Class++ !  Here, you will learn what you need to install Class++, how to install it, and how to create a basic testing script.</p>"},{"location":"tutorials/#requirements","title":"Requirements","text":"<p>To use Class++, you don't need to be an expert developer, all you need is:</p> <ul> <li>Basic understanding on the concept of OOP (Object Oriented Programming), and Classes.</li> <li>Basic understanding on how metatables work in Roblox.</li> </ul> <p>Basically, if you're already experienced with OOP, you're good to go!  Especially, if you already have knowledge in languages like C++ and Java, your job will be pretty easy.</p>"},{"location":"tutorials/#installation","title":"Installation","text":"<p>Installing Class++ is pretty easy! Just head over to this link to download the <code>.rbxm</code> file that contains the source code.</p> <p>After the download, open Roblox Studio, go into the place that you want to import Class++ to, and right click on the <code>ReplicatedStorage</code> (or the location that you want to insert into), and select \"Insert from File\".</p> <p>Select the <code>ClassPP.rbxm</code> file that you just downloaded, and if the <code>ClassPP</code> module script has appeared, congratulations, the installation is complete!</p>"},{"location":"tutorials/#creating-a-testing-script","title":"Creating A Testing Script","text":"<p>Now that you've installed Class++, we can create a script to test if it has been successfully installed:</p> <ul> <li>1: Create a <code>Script</code> or a <code>LocalScript</code> instance, and parent it to <code>workspace</code> or <code>StarterPlayer &gt; StarterPlayerScripts</code>.</li> <li>2: Remove the <code>print(\"Hello World\")</code> line, and paste the following code in:</li> </ul> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\") -- If you've inserted it to somewhere else, you can change this line.\nlocal ClassPP = require(ReplicatedStorage.ClassPP)\nlocal class = ClassPP.class\n</code></pre> <ul> <li>3: Press \"Play\" or \"Run\". If everything is working properly and there are no errors, you're good to go!</li> </ul>"},{"location":"tutorials/advanced/friendAccessSpecifier/","title":"Friend Access Specifier","text":"<p>Friend access specifier allows anyone defined in that access specifier to access the private members of a class.</p> <p>Warning</p> <p>Members of this access specifier will not be replicated to objects, rather, these members are stored in the class itself. And they can only be used to allow functions or classes to have access to Private or Protected members of a class.</p> <pre><code>local function getLicensePlate(object: any)\n    print(object.License_Plate)\nend\n\nlocal class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    },\n    Friend = {\n        getLicensePlate\n    }\n}\n\nlocal newCar = Car.new()\ngetLicensePlate(newCar)\n</code></pre> <p>In this example, we updated the previous class to include a function in the <code>Friend</code> access specifier, this function is now able to access the private members of this class. </p> <p>Info</p> <p>Aside from functions, <code>Friend</code> access specifier can include other classes as well. Classes can be saved by using their variables, or their names. You can put a string inside the <code>Friend</code> access specifier that has a class's name, and it will still work!</p>"},{"location":"tutorials/advanced/functionOverloading/","title":"Function Overloading","text":"<p>Just like in other OO languages, Class++ supports function overloading.  Function Overloading is a feature where multiple functions can share the same name, but they are different from each other with different amount of arguments.</p> <p>To do function overloading in Class++, you have to use the <code>class.overload(&lt;accessSpecifier&gt;, &lt;name&gt;, &lt;functionTable&gt;)</code> function.</p> <pre><code>local class = ClassPP.class\n\nlocal Test = class \"Test\" {\n    Public = {\n        ValueA = 0,\n        ValueB = 0\n    }\n}\n\nTest.overload(\"Public\", \"Set\", {\n    function(self, a, b)\n        print(a, b)\n        self.ValueA = a\n        self.ValueB = b\n    end,\n    function(self, a)\n        print(a)\n        self.ValueA = a\n    end,\n    function(self)\n        print(self.ValueA, self.ValueB)\n    end\n})\n\nlocal newTest = Test.new()\nnewTest:Set(1, 2) -- Prints \"1 2\"\nnewTest:Set(3) -- Prints \"3\"\nnewTest:Set() -- Prints \"3 2\"\n</code></pre> <p>In this example, to create an overloaded function, we used the <code>.overload()</code> function with the <code>Public</code> access specifier, and <code>Set</code> for the function name. Then we gave a table with multiple functions with different arguments that each do a different action. When we call the <code>:Set()</code> function through the object, depending on the amount of the given arguments, only the function that accepts the same amount of arguments will be ran.</p> <p>Warning</p> <p>Giving multiple functions that have the same amount of arguments will cause only one of these functions to be ran. Only create one function for a specific amount of arguments.</p>"},{"location":"tutorials/advanced/inheritance/","title":"Inheritance","text":"<p>Just like in C++ and many other languages, Class++ allows you to inherit classes.  We group the inheritance concept into two categories: derived class (child), and the base class (parent). Inheritance implements an is-a relationship between classes.</p> <pre><code>local class = ClassPP.class\n\nlocal Vehicle = class \"Vehicle\" { -- Base Class\n    Public = {\n        Brand = \"Tesla\",\n        Model = \"S\",\n        License_Plate = \"BITE 1987\",\n        Year = 2012,\n        honk = function(self)\n            print(\"honk honk!\")\n        end\n    }\n}\n\nlocal Car = class \"Car\" (Vehicle, nil) { -- Derived Class\n    Public = {\n        License_Plate = \"A1B2C3\"\n    }\n}\n\nlocal newCar = Car.new()\nnewCar:honk()\nprint(newCar.Brand, newCar.Model, newCar.License_Plate, newCar.Year) -- Prints \"Tesla S A1B2C3 2012\"!\n</code></pre> <p>In this example, we have 2 classes: The Vehicle class (base), and the Car class (child).  We created the Car class by providing the <code>class</code> function a list of classes to inherit from (in this case, only the Vehicle class), and the <code>classData</code> table after.</p> <p>When you create a class using this method, you create a new derived class that inherits all of the members and member functions from the class(es) provided, so you don't need to re-declare them again. The members are overwritable in the derived class, like in the example above, you can modify the <code>License_Plate</code>'s default value to anything you wish. The same applies to other members.</p> <p>Question</p> <p>\"Why should I use Inheritence?\" It's very useful for code reusability: reusing members and functions of an existing class when you're creating a new class will save you a lot of time and effort, defining same members over and over again may cause spaghetti code and decrease code readability.</p>"},{"location":"tutorials/advanced/inheritance/#multilevel-inheritance","title":"Multilevel-Inheritance","text":"<p>A class can also be derived from one class, which can be derived from another class:</p> <pre><code>local class = ClassPP.class\n\nlocal Person = class \"Person\" { -- Base Class\n    Public = {\n        Name = \"\",\n        Age = 0,\n        Gender = \"\",\n        Height = 0\n    }\n}\n\nlocal Child = class \"Child\" (Person, nil) { -- Derived Class\n    Public = {\n        Age = 9,\n        Energetic = true\n    }\n}\n\nlocal Student = class \"Student\" (Child, nil) { -- Derived Class from a Derived Class\n    Public = {\n        SchoolId = 0,\n        Grade = 0,\n        Behaviour = \"Good\"\n    }\n}\n\nlocal newStudent = Student.new()\nprint(newStudent.Name, newStudent.Age, newStudent.Gender, newStudent.Height, newStudent.Age, newStudent.Energetic, newStudent.SchoolId, newStudent.Grade, newStudent.Behaviour)\n-- Prints \" 9  0 9 true 0 0 Good\"! (Spaces represent empty strings)\n</code></pre>"},{"location":"tutorials/advanced/inheritance/#protected-access-specifier","title":"Protected Access Specifier","text":"<p>In the Access Specifiers section, you have learned that there are 4 access specifiers in Class++, so far you have seen <code>Public</code>, <code>Private</code> and <code>Friend</code>. The fourth specifier, <code>Protected</code>, is pretty much the same as the <code>Private</code>, however, aside from the class members, inherited classes will also be able to access these members. </p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Protected = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal BiggerCar = class \"BiggerCar\" (Car, nil) {\n    Public = {\n        Brand = \"Tesla\"\n    }\n}\n\nfunction BiggerCar.Public:printLicensePlate()\n    print(self.License_Plate) -- Will print \"XXXX\"!\nend\n\nlocal newCar = BiggerCar.new()\nnewCar:printLicensePlate()\n</code></pre> <p>In this example, we put the member <code>License_Plate</code> under the <code>Protected</code> access specifier, and created a new class inherited from the Car class. The inherited class and it's member functions will now be able to access this member. </p>"},{"location":"tutorials/advanced/inheritance/#super","title":"super","text":"<p>Let's say that you want to access a function in the base class from a child class, how would you do it? Creating a new object from the base class and calling the function would be tedious, as it would take longer to write and would decrease performance.</p> <p>Fortunately, for this, you can call the default <code>super</code> method of the object, which allows you to call the function in the base class that has the same name of the function this method has been called from.</p> <pre><code>local class = ClassPP.class\n\nlocal A = class \"A\" { \n    Public = {\n        getVariable = function(self)\n            return self.Variable_A\n        end\n    },\n    Protected = {\n        Variable_A = 1\n    }\n}\n\nlocal B = class \"B\" (A, nil) { \n    Public = {\n        Variable_B = 1,\n        getVariable = function(self)\n            return self:super()\n        end\n    }\n}\n\nlocal newObject = B.new()\nprint(newObject:getVariable()) -- 1\n</code></pre> <p>In this example, we created a new class called \"B\" that inherits from \"A\". In both classes, we have a function called \"getVariable\", in the base class, this function returns the \"Variable_A\" member's value, and in the child class, this function returns the value from the \"getVariable\" function from the parent class, by calling the <code>super()</code> method. </p> <p>Warning</p> <p><code>super</code> cannot be used within classes that have multi-inheritance. This is due to ambiguity that occurs with functions that have the same name in classes that have multi-inheritance. </p>"},{"location":"tutorials/advanced/inheritance/#multi-inheritance","title":"Multi-Inheritance","text":"<p>A class can also be derived from multiple classes:</p> <pre><code>local class = ClassPP.class\n\nlocal A = class \"A\" { \n    Public = {\n        Variable_A = 1\n    }\n}\n\nlocal B = class \"B\" { \n    Public = {\n        Variable_B = 1\n    }\n}\n\nlocal C = class \"C\" (A, B) { -- Derived Class\n    Public = {\n        Variable_C = 1\n    }\n}\n\nlocal newObject = C.new() -- {Variable_A: number, Variable_B: number, Variable_C: number}\n</code></pre>"},{"location":"tutorials/advanced/inheritance/#the-diamond-problem","title":"The Diamond Problem","text":"<p>The Diamond Problem is an ambiguity that arises when two classes, let's say \"B\" and \"C\", that inherits from a class called \"A\", and another class \"D\" that inherits from both \"B\" and \"C\". If there is a method in \"A\" that \"B\" and \"C\" have overridden, and \"D\" does not override it, then which version of the method does \"D\" inherit from: that of \"B\", or that of \"C\"?</p> <pre><code>local class = ClassPP.class\n\nlocal A = class \"A\" { \n    Public = {\n        method = function(self)\n            print(\"Method from A\")\n        end\n    }\n}\n\nlocal B = class \"B\" (A, nil) { \n    Public = {\n        method = function(self)\n            print(\"Method from B\")\n        end\n    }\n}\n\nlocal C = class \"C\" (A, nil) { -- Derived Class\n    Public = {\n        method = function(self)\n            print(\"Method from C\")\n        end\n    }\n}\n\nlocal D = class \"D\" (B, C) { -- Derived Class\n    Public = {\n        -- Which method will D have, B's or C's?\n    }\n}\n</code></pre>"},{"location":"tutorials/advanced/inheritance/#how-class-solves-the-diamond-problem","title":"How Class++ solves the Diamond Problem","text":"<p>In Class++, the class inheritation system does not work by referencing the parent classes, but rather for the sake of performance, it combines the given classes into a new one. The combination is done in an order, from the first given class argument to the last. Certain Access Specifiers such as Protected can change how this system behaves.</p> <p>To create class \"D\", Class++ takes the class arguments one by one in an order, from left to right, and combines their <code>classData</code> and the given <code>classData</code> table into a new class. So due to this order, class \"B\"'s members and methods will automatically be overwritten by class \"C\"'s, therefore the method that will exist on class \"D\", will be the method of class \"C\"'s.</p> <p>This is similar to the Python's MRO (Method Resolution Order).</p> <pre><code>local class = ClassPP.class\n\nlocal A = class \"A\" { \n    Public = {\n        method = function(self)\n            print(\"Method from A\")\n        end\n    }\n}\n\nlocal B = class \"B\" (A, nil) { \n    Public = {\n        method = function(self)\n            print(\"Method from B\")\n        end\n    }\n}\n\nlocal C = class \"C\" (A, nil) { -- Derived Class\n    Public = {\n        method = function(self)\n            print(\"Method from C\")\n        end\n    }\n}\n\nlocal D = class \"D\" (B, C) {} -- Derived Class\n\nlocal newObject = D.new()\nnewObject:method() -- Prints \"Method from C\"!\n</code></pre>"},{"location":"tutorials/advanced/nonAccessSpecifiers/","title":"Non-Access Specifiers","text":"<p>Unlike access specifiers, non-access specifiers do not modify the access control of a member, but rather provide other functionality for classes.</p>"},{"location":"tutorials/advanced/nonAccessSpecifiers/#final","title":"Final","text":"<p>Using this non-access specifier will make the given class final, meaning this class now cannot be inherited by other classes.</p> <pre><code>local class, final = ClassPP.class, ClassPP.final\n\nlocal Car = final { class \"Car\" {\n    Public = {\n        Brand = \"Ford\",\n    }\n}}\n\nlocal BiggerCar = class \"BiggerCar\" (Car, nil) { -- This will error!\n    Public = {\n        Brand = \"Tesla\"\n    }\n}\n</code></pre>"},{"location":"tutorials/advanced/nonAccessSpecifiers/#abstract","title":"Abstract","text":"<p>Using this non-access specifier will make the given class an abstract class, meaning this class now cannot be used to create objects. To access an abstract class's members, you need to create a class that inherits from this abstract class.</p> <pre><code>local class, abstract = ClassPP.class, ClassPP.abstract\n\nlocal BaseCar = abstract { class \"BaseCar\" {\n    Public = {\n        Brand = \"\",\n        Model = \"\",\n        Year = 0,\n        honk = function(self)\n            print(\"honk honk!\")\n        end\n    }\n}}\n\nlocal Car = class \"Car\" (BaseCar, nil) {\n    Public = {\n        Brand = \"Ford\",\n        Model = \"Mustang\",\n        Year = 2023\n    }\n}\n\nlocal newBaseCarObj = BaseCar.new() -- This will error!\nlocal newCarObj = Car.new() -- This will work fine!\nnewCarObj:honk()\n</code></pre> <p>Warning</p> <p>Creating Private members in an abstract class will cause these members to never be accessible, since Private members of a class will never be inherited to another class.</p> <pre><code>local class, abstract = ClassPP.class, ClassPP.abstract\n\nlocal BaseCar = abstract { class \"BaseCar\" {\n    Public = {\n        Brand = \"\",\n        Model = \"\",\n        Year = 0,\n        honk = function(self)\n            print(\"honk honk!\")\n        end\n    },\n    Private = {\n        Secret = \"\" -- This property will never be accessible!\n    }\n}}\n</code></pre> <p>Warning</p> <p>You cannot make a class both abstract and final, as they have opposite meanings. An abstract class must be subclassed, whereas a final class cannot be subclassed. Attempting to form an illegal combination between final and abstract methods will cause an error.</p>"},{"location":"tutorials/advanced/operatorOverloading/","title":"Operator Overloading","text":"<p>Suppose we have two objects that belong to a custom Vector class, how would we allow the addition of those two objects? Using a normal class function would suffice, but it would require you to call the same function over and over again every single time you want to add them together.</p> <p>To solve this issue, just like in other OO languages, we can change the way operators work for our classes. This is known as operator overloading.</p> <pre><code>local class = ClassPP.class\n\nlocal Vector = class \"Vector3\" {\n    constructor = function(self, x: number, y: number, z: number)\n        if typeof(x) ~= \"number\" or typeof(y) ~= \"number\" or typeof(z) ~= \"number\" then self.coordinates = {0, 0, 0} return end\n        self.coordinates = {x, y, z}\n    end,\n    Public = {\n        coordinates = {0, 0, 0},\n    },\n}\n\nfunction Vector.Public:operator_add(otherVector)\n    assert(#self.coordinates == #otherVector.coordinates)\n\n    local coordinates = {}\n\n    for i = 1, #self.coordinates do\n        coordinates[i] = self.coordinates[i] + otherVector.coordinates[i]\n    end\n\n    return Vector.new(coordinates[1], coordinates[2], coordinates[3])\nend\n\nfunction Vector.Public:__tostring()\n    return \"(\" .. table.concat(self.coordinates, \", \") .. \")\"\nend\n\nlocal vector1 = Vector.new(4, 5, 2)\nlocal vector2 = Vector.new(1, 2, 3)\n\nprint(vector1 + vector2) -- Prints \"(5, 7, 5)\"\n</code></pre> <p>In this example, we have created a custom Vector3 class that has a special function called <code>operator_add</code>, this special function is one of the special functions in Class++ that allows you to overload a specific operator. Here, we overloaded the operator <code>+</code> with our custom function that allows us to add two Vectors together.</p>"},{"location":"tutorials/advanced/operatorOverloading/#overloadable-operators","title":"Overloadable Operators","text":"<pre><code>&lt;div class=\"operator_overloading_table\"&gt;\n    &lt;div class=\"md-typeset__scrollwrap\"&gt;\n        &lt;div class=\"md-typeset__table\"&gt;\n            &lt;table&gt;\n                &lt;thead&gt;\n                    &lt;tr&gt;\n                    &lt;th class=\"operator_overloading_method\"&gt;Method&lt;/th&gt;\n                    &lt;th class=\"operator_overloading_description\"&gt;Description&lt;/th&gt;\n                    &lt;/tr&gt;\n                &lt;/thead&gt;\n                &lt;tbody&gt;\n                    &lt;tr&gt;\n                    &lt;td&gt;&lt;code&gt;operator_add(self, obj)&lt;/code&gt;&lt;/td&gt;\n                    &lt;td&gt;Function for overloading the + operator.&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                    &lt;td&gt;&lt;code&gt;operator_sub(self, obj)&lt;/code&gt;&lt;/td&gt;\n                    &lt;td&gt;Function for overloading the - operator.&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                    &lt;td&gt;&lt;code&gt;operator_mul(self, obj)&lt;/code&gt;&lt;/td&gt;\n                    &lt;td&gt;Function for overloading the * operator.&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                    &lt;td&gt;&lt;code&gt;operator_div(self, obj)&lt;/code&gt;&lt;/td&gt;\n                    &lt;td&gt;Function for overloading the / operator.&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                    &lt;td&gt;&lt;code&gt;operator_idiv(self, obj)&lt;/code&gt;&lt;/td&gt;\n                    &lt;td&gt;Function for overloading the // operator.&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                    &lt;td&gt;&lt;code&gt;operator_mod(self, obj)&lt;/code&gt;&lt;/td&gt;\n                    &lt;td&gt;Function for overloading the % operator.&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                    &lt;td&gt;&lt;code&gt;operator_pow(self, obj)&lt;/code&gt;&lt;/td&gt;\n                    &lt;td&gt;Function for overloading the ^ operator.&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                    &lt;td&gt;&lt;code&gt;operator_unm(self)&lt;/code&gt;&lt;/td&gt;\n                    &lt;td&gt;Function for overloading the unary \u2013 operator.&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                    &lt;td&gt;&lt;code&gt;operator_eq(self, obj)&lt;/code&gt;&lt;/td&gt;\n                    &lt;td&gt;Function for overloading the == operator.\u00b9&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                    &lt;td&gt;&lt;code&gt;__tostring()&lt;/code&gt;&lt;/td&gt;\n                    &lt;td&gt;Fired when tostring is called on the object.&lt;/td&gt;\n                    &lt;/tr&gt;\n                &lt;/tbody&gt;\n            &lt;/table&gt;\n</code></pre> <pre><code>    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>Info</p> <p>\u00b9: This function will only run when == operator is used with the same base type (table, userdata, etc.). It will not work with different types, such as an object with a table, or another type.</p> <p>Warning</p> <p>Trying to directly call the operator functions will result in an error. They must be called with their operators.</p>"},{"location":"tutorials/advanced/staticMembers/","title":"Static Members","text":"<p>Static members are members of the class that will exist regardless of whether or not any objects of the class are created. Once a static member has been created, they cannot be destroyed or modified in any way. Static members are also global, so all class objects have access to them, and their property will be the same across all of the objects.</p> <p>To create a static member in Class++, you have to use the <code>class.static(&lt;accessSpecifier&gt;, &lt;name&gt;, &lt;property&gt;)</code> function.</p> <pre><code>local class = ClassPP.class\n\nlocal Test = class \"Test\" {\n    Public = {\n        TestValue = 0\n    }\n}\n\nTest.static(\"Public\", \"StaticTestValue\", function(firstArgument)\n    print(firstArgument) -- This will not point to any object, instead it will print whatever it is called with! In this case, it will print \"Hi!\".\nend)\n\nlocal newTest = Test.new()\nnewTest:StaticTestValue() -- This will error!\n\nTest.StaticTestValue(\"Hi!\") -- This will work fine!\n</code></pre> <p>You can also give properties that aren't functions. To retrieve those properties, you can do <code>class.&lt;memberName&gt;.property</code> or <code>class.&lt;memberName&gt;.p</code> for short.</p> <pre><code>local class = ClassPP.class\n\nlocal Test = class \"Test\" {\n    Public = {\n        TestValue = 0\n    }\n}\n\nTest.static(\"Public\", \"StaticTestValue\", 1)\n\nprint(Test.StaticTestValue.property) -- Prints \"1\"!\nprint(Test.StaticTestValue.p) -- Also prints \"1\"!\n</code></pre>"},{"location":"tutorials/advanced/types/","title":"Types","text":""},{"location":"tutorials/advanced/types/#intellisense","title":"Intellisense","text":"<p>Class++ in 2.0, has been rewritten from ground up to support the new type-solver and its capabilities.  This allows Class++ to be more intelligent with the <code>class</code> and <code>object</code> types, finally allowing the intellisense to be far better than what it used to be. </p> <pre><code>local Person = class \"Person\" {\n    Public = {\n        Age = 0,\n        Name = \"\",\n        Personality = \"\",\n        Likes = {},\n        Dislikes = {},\n        Job = \"\",\n        getSecrets = function(self)\n            return self.Secrets\n        end,\n    },\n    Private = {\n        Secrets = {}\n    }\n}\n\nlocal newPerson = Person.new() -- Now has intellisense for members in all access specifiers, and obtains the correct types for every member!\n</code></pre> <p>This also applies to classes, where before you tried to create an inherited class, the returned class type would not be correct, and new objects would also not have the correct type. For example, some members of an inherited class would be missing from auto-complete.</p> <p>Now, this has also been fixed:</p> <pre><code>local class = ClassPP.class\n\nlocal A = class \"A\" { \n    Public = {\n        Variable_A = 1\n    }\n}\n\nlocal B = class \"B\" { \n    Public = {\n        Variable_B = 1\n    }\n}\n\nlocal C = class \"C\" (A, B) { -- Derived Class\n    Public = {\n        Variable_C = 1\n    }\n}\n\nlocal newObject = C.new() -- {Variable_A: number, Variable_B: number, Variable_C: number}\n</code></pre> <p>Though, as much as this update brings in an intellisense much better than before, it is still limited. Like in the previous versions of Class++, to support all the features of types in Luau, you have to create a custom type and assign it to the created objects.</p> <p>In the tutorial below, you will learn how to create a basic <code>Person</code> type and assign it to the created object, to enable the support.</p>"},{"location":"tutorials/advanced/types/#creating-a-basic-custom-class-type","title":"Creating a Basic Custom Class Type","text":"<pre><code>local class = ClassPP.class\n\ntype Person = {\n    Age: number,\n    Name: string,\n    Personality: string,\n    Job: string,\n    Secrets: {string},\n    Likes: {string},\n    Dislikes: {string},\n    getSecrets: (self: Person) -&gt; {string}\n}\n\nlocal Person = class \"Person\" {\n    Public = {\n        Age = 0,\n        Name = \"\",\n        Personality = \"\",\n        Likes = {},\n        Dislikes = {},\n        Job = \"\",\n        getSecrets = function(self: Person)\n            return self.Secrets\n        end,\n    },\n    Private = {\n        Secrets = {}\n    }\n}\n\nlocal newPerson: Person = Person.new()\n-- This object now fully supports all type features of Luau!\n</code></pre> <p>In the example above, we created a custom type called <code>Person</code> for the Person class, and inserted the types of all the members inside it, and declared the new created object as of the Person type. This now allows us to use all the features of Luau types.</p> <p>Info</p> <p>Since class objects belong to the base type <code>userdata</code>, you can type cast them to either your custom types, or any other existing type you wish.</p>"},{"location":"tutorials/advanced/types/#typechecking-for-classes-and-class-objects","title":"Typechecking for Classes and Class Objects","text":"<p>Class++ also comes with its own <code>Type</code> API that allows you to get the types of <code>class</code>es and <code>object</code>s.</p> <pre><code>local class = ClassPP.class\nlocal type, typeof = ClassPP.Type.type, ClassPP.Type.typeof\n\ntype Person = {\n    Age: number,\n    Name: string,\n    Personality: string,\n    Job: string,\n    Secrets: {string},\n    Likes: {string},\n    Dislikes: {string},\n    getSecrets: (self: Person) -&gt; {string}\n}\n\nlocal Person = class \"Person\" {\n    Public = {\n        Age = 0,\n        Name = \"\",\n        Personality = \"\",\n        Likes = {},\n        Dislikes = {},\n        Job = \"\",\n        getSecrets = function(self: Person)\n            return self.Secrets\n        end,\n    },\n    Private = {\n        Secrets = {}\n    }\n}\n\nlocal newPerson: Person = Person.new()\nprint(type(Person), \",\", type(newPerson)) -- Prints \"Class, Object\"!\nprint(typeof(Person), \",\", typeof(newPerson)) -- Prints \"Person, Person\"!\n</code></pre>"},{"location":"tutorials/advanced/types/#typetype","title":"Type.type","text":"<p><code>Type.type</code> will return the true type of the given object. It behaves the same as the built-in luau <code>type</code> function, but with additional support for <code>class</code>es and <code>object</code>s. For example, if the provided object is a <code>class</code>, it will return a string called \"Class\". This is due to the <code>class</code> object belonging to the base <code>Class</code> type.</p> <p>The same applies to <code>object</code>s, where if the provided object is an <code>object</code>, it will return a string called \"Object\". This is due to the <code>object</code> belonging to the base <code>Object</code> type.</p>"},{"location":"tutorials/advanced/types/#typetypeof","title":"Type.typeof","text":"<p><code>Type.typeof</code> will return the type of the given object. Like <code>Type.type</code>, it behaves the same as the built-in Roblox <code>typeof</code> function, but with additional support for <code>class</code>es and <code>object</code>s. For example, if the provided object is a <code>class</code>, it will return a string containing the name of the <code>class</code>. This is due to <code>class</code>es are also being types on their own. They can also be represented as types.</p> <p>For <code>object</code>s, this function will return the type of the <code>class</code> they belong to. For example, using this function with an <code>object</code> created from a \"Person\" <code>class</code>, will return \"Person\" as its type.</p> <p>Info</p> <p><code>Type.type</code> and <code>Type.typeof</code> functions can be used to replace the built-in <code>type</code> and <code>typeof</code> functions, as they behave the same with other provided objects. For example, using <code>Type.typeof</code> and <code>typeof</code> with a <code>string</code> will both return \"string\".</p> <p>Warning</p> <p>Using the <code>class.Name</code> property may create bugs in certain places as the Type API makes sure the given object is an actual <code>class</code> object before returning its type. It's recommended that you use the Type API instead of the <code>.Name</code> property.</p>"},{"location":"tutorials/basics/accessSpecifiers/","title":"Access Specifiers","text":"<p>Unlike any other class module or system on Roblox, Class++ comes with an Access Specifier system. Like in other OO (Object Oriented) languages such as C++, it provides you a way to modify the access control of a member. There are 4 access specifiers in Class++: <code>Public</code>, <code>Private</code>, <code>Protected</code>, and <code>Friend</code>. (<code>Protected</code> and <code>Friend</code> are mentioned in later pages.)</p>"},{"location":"tutorials/basics/accessSpecifiers/#public-access-specifier","title":"Public Access Specifier","text":"<p>Like you have seen in the examples on the previous page, a Public Access Specifier allows anyone to access a member. Whether it be from a function inside the class or from the script's main thread, the member is accessible and can be modified.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    }\n}\n\nlocal newCar = Car.new()\nnewCar.Brand = \"Tesla\"\n</code></pre> <p>In this example, we created a new class with a Public member <code>Brand</code> that has the default value of <code>Lamborghini</code>. Then we created a new object from this class and modified the <code>Brand</code> member of this object. Now the value is set to <code>Tesla</code>.</p>"},{"location":"tutorials/basics/accessSpecifiers/#private-access-specifier","title":"Private Access Specifier","text":"<p>Private access specifier allows you to hide a member from anyone outside from that class. No one besides the class members can access this member or modify it.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal newCar = Car.new()\nnewCar.License_Plate = \"YYYY\" -- This will error!\n</code></pre> <p>In this example, we updated the previous class with a private member named <code>License_Plate</code>, this member is private and can only be accessed by the class members, so trying to access or modify it outside of the class will cause an error.</p> <p>Warning</p> <p>A member (property/attribute) can be declared only once. This means a member can only be defined under one access specifier. Attempting to declare a member in multiple access specifiers will cause an error.</p>"},{"location":"tutorials/basics/classConstructors/","title":"Class Constructors and Destructors","text":"<p>Up until this point, when we created an object from a class and we wanted to update the object, we had to update it either in a class function or outside of the class. Especially when it comes to updating private members, this can get tedious, as you have to define a class method if you want to update them after creation. </p> <p>Fortunately, to solve these issues, there are 2 special functions that you can define in every class, called: <code>constructor</code> and <code>destructor</code>.</p>"},{"location":"tutorials/basics/classConstructors/#class-constructors","title":"Class Constructors","text":"<p>A constructor is a special function that gets called when an object is created. To create a constructor, you have to specifically define a function called <code>constructor</code> outside of the Access Specifiers. Constructors can be really useful for setting initial values for certain members.</p> <p><pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    constructor = function(self)\n        self.License_Plate = \"YYYY\"\n    end,\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal newCar = Car.new()\n</code></pre> When <code>Car.new()</code> is called, the function will automatically call the constructor function.</p>"},{"location":"tutorials/basics/classConstructors/#constructor-parameters","title":"Constructor Parameters","text":"<p>Constructors, like regular class methods, can take parameters. Unlike class methods however, a constructor will always have <code>self</code> as the first parameter, regardless of how you call the <code>class.new()</code> function.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    constructor = function(self, brand, model, licensePlate)\n        self.License_Plate = licensePlate\n        self.Brand = brand\n        self.Model = model\n    end,\n    Public = {\n        Brand = \"\",\n        Model = \"\",\n        License_Plate = \"\"\n    },\n}\n\nlocal newCar = Car.new(\"ABCD\", \"Ford\", \"Mustang\")\nprint(newCar.Brand, newCar.Model, newCar.License_Plate) -- Prints \"ABCD, Ford, Mustang\"!\n</code></pre>"},{"location":"tutorials/basics/classConstructors/#class-destructors","title":"Class Destructors","text":"<p>A destructor is a special function that runs when you call the default <code>:Destroy()</code> method on an object. To create a destructor, you have to specifically define a function called <code>destructor</code> outside of the Access Specifiers.</p> <p>Info</p> <p><code>object:Destroy()</code> is a reserved special method that all objects have. Due to this, you cannot define any member or a method that is called \"Destroy\".</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    constructor = function(self, brand, model, licensePlate)\n        self.License_Plate = licensePlate\n        self.Brand = brand\n        self.Model = model\n    end,\n    destructor = function(self)\n        self.License_Plate = \"\"\n        self.Brand = \"\"\n        self.Model = \"\"\n    end,\n    Public = {\n        Brand = \"\",\n        Model = \"\",\n        License_Plate = \"\"\n    },\n}\n\nlocal newCar = Car.new(\"ABCD\", \"Ford\", \"Mustang\")\nprint(newCar.Brand, newCar.Model, newCar.License_Plate)\n\nnewCar:Destroy() -- The class object will now be destroyed\nnewCar = nil\n</code></pre> <p>Unlike <code>constructor</code>, the <code>destructor</code> function does not take any additional parameters, and the only parameter will be the <code>self</code> pointing to the object. After the <code>destructor</code> is called, all members inside the object will be set to <code>nil</code>, and the object will be locked, preventing any further access. At this stage, the object should be treated as completely empty and gone, so you should remove all references to the object to prevent memory leaks.</p> <p>Instances, threads and connections inside an object will automatically be destroyed and cleared during the clearing process as well.</p> <p>Warning</p> <p>While manual memory management is recommended, Class++ will automatically call the <code>destructor</code> on any object that no longer has any references. This is to prevent memory leaks that might cause many problems if you have objects that can put a heavy toll on the memory.</p> <p>Info</p> <p>Constructor and Destructor functions can also be written in the outside class definition syntax.</p>"},{"location":"tutorials/basics/classCreation/","title":"Classes and Objects","text":"<p>A class is an user defined data structure. It's made out of members and member functions. Those members and member functions can then be accessed by creating an object from that class. Think of a class as a blueprint for an object.</p>"},{"location":"tutorials/basics/classCreation/#creating-a-class","title":"Creating a Class","text":"<p>Here's an example of a person class:</p> <p><pre><code>local class = ClassPP.class\n\nlocal person = class \"Person\" {\n    Public = {\n        Name = \"\",\n        Age = 0\n    }\n}\n</code></pre> To create a new basic class, you use the <code>class()</code> function with the above syntax. The first argument will be a string that defines the name of the class, and the next argument is the class data, a table that contains all the access specifiers and the member data.</p> <p>In the above example, we created a new class with the name <code>Person</code>, and we created two members named: <code>Name</code> and <code>Age</code>.  Then, we assigned default values to them. These values will be transferred to the object when it gets created.</p>"},{"location":"tutorials/basics/classCreation/#creating-an-object","title":"Creating an Object","text":"<p>Now that you have learned how to create classes, it's time to learn how to create objects. In Class++, to create an object, you use the <code>class.new()</code> function. This function returns an object created from this class, and will contain all of the members that you've defined.</p> <pre><code>local class = ClassPP.class\n\nlocal person = class \"Person\" {\n    Public = {\n        Name = \"\",\n        Age = 0\n    }\n}\n\nlocal newPerson = person.new()\nprint(newPerson.Age) -- Prints \"0\"!\n</code></pre> <p>Objects will have the members and their default values that you've set in the class data table, so if you want to update them, you can simply index the object with the member and set it to something else!</p> <pre><code>local class = ClassPP.class\n\nlocal person = class \"Person\" {\n    Public = {\n        Name = \"\",\n        Age = 0\n    }\n}\n\nlocal newPerson = person.new()\nnewPerson.Age = 21\n\nprint(newPerson.Age) -- Prints \"21\"!\n</code></pre> <p>Warning</p> <p>Unlike the classic class creation method on Luau that programmers use, in Class++, to define a member you must do it through the <code>class()</code> function (Or by simply indexing the class). Trying to define a new member through the object will cause an error.</p> <pre><code>local class = ClassPP.class\n\nlocal person = class \"Person\" {\n    Public = {\n        Name = \"\",\n        Age = 0\n    }\n}\n\nlocal newPerson = person.new()\nnewPerson.Personality = \"Cheerful\" -- This will error! This class has no member named \"Personality\".\n</code></pre>"},{"location":"tutorials/basics/classMethods/","title":"Class Functions","text":"<p>Just like in other OO languages, there are two ways to define a function (method) inside a class:</p> <ul> <li>Inside class definition</li> <li>Outside class definition</li> </ul>"},{"location":"tutorials/basics/classMethods/#inside-class-definition","title":"Inside Class Definition","text":"<pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n        getLicensePlate = function(self)\n            print(self.License_Plate)\n        end\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n</code></pre> <p>In this example, we have defined a function inside the Public Access Specifier called <code>getLicensePlate</code>, this function when called will print the license plate of our object. </p> <p>Now, let's create an object from this class:</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n        getLicensePlate = function(self)\n            print(self.License_Plate)\n        end\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal newCar = Car.new()\nnewCar:getLicensePlate()\n</code></pre> <p>You might have noticed that we've called the <code>getLicensePlate</code> function with the <code>:</code> (colon) operator. This is a syntax sugar that we use to pass the object itself as the first argument to a function. Calling a function with the <code>:</code> operator is equivalent to calling it like <code>object.method(object)</code>, but it makes our job easier because we don't have to manually pass the object every single time.</p> <p>Due to this, the first argument of a function will always be what we call <code>self</code>, that is a pointer to the object. We use it to access the object's properties and functions from a class function.</p>"},{"location":"tutorials/basics/classMethods/#functions-with-multiple-parameters","title":"Functions with multiple parameters","text":"<pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n        setLicensePlate = function(self, newPlate)\n            self.License_Plate = newPlate \n        end,\n        getLicensePlate = function(self)\n            return self.License_Plate\n        end\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal newCar = Car.new()\nnewCar:setLicensePlate(\"A1B2C3\") -- Calling the function with an argument\nprint(newCar:getLicensePlate()) -- Prints \"A1B2C3\"!\n</code></pre> <p>In the example above, we added a new function called <code>setLicensePlate</code> that updates the private member <code>License_Plate</code> with the provided <code>newPlate</code> parameter. We've also updated the <code>getLicensePlate</code> function to return the private member <code>License_Plate</code>, which we then use to print the now updated value of the member. As you can see, you can call the class functions with multiple parameters easily by following the method in the example. </p> <p>You can also notice that since the <code>self</code> is the first argument, all the other arguments that come after will start at 2.</p>"},{"location":"tutorials/basics/classMethods/#outside-class-definition","title":"Outside Class Definition","text":"<p>To define a function outside of the class, you must define it as: <code>function Class.&lt;accessSpecifier&gt;:&lt;functionName&gt;</code></p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nfunction Car.Public:getLicensePlate(number)\n    print(self.License_Plate, number) -- Prints \"XXXX 1\"!\nend\n\nlocal newCar = Car.new()\nnewCar:getLicensePlate(1)\n</code></pre> <p>In this example, we defined a function outside of the class by specifying the class name, then the access specifier, followed by the <code>:</code> operator and the name of the function. Unlike in some other OO languages, you do not have to define the function inside the class first to use this method.</p> <p>Info</p> <p>Outside Class Definition syntax is recommended as it allows for a better formatting style.</p> <p>Info</p> <p>Class Functions are also called Class Methods, and we will use this term from now on in later pages.</p>"},{"location":"tutorials/best-practices/composition/","title":"Composition","text":"<p>Composition is another fundemental concept in OOP that combines objects or data types into more complex ones. This implements a has-a relationship between objects, rather than is-a from Inheritance.</p> <p>For example, let's imagine a coffee machine. This coffee machine has a grinder, a brewer, and many other components, but the coffee machine itself is not one of them.</p>"},{"location":"tutorials/best-practices/composition/#composition-over-inheritance","title":"Composition Over Inheritance","text":"<p>(Coming Soon)</p>"},{"location":"tutorials/best-practices/encapsulation/","title":"Encapsulation","text":"<p>Encapsulation is a fundamental concept in OOP that combines data (properties) and methods (class functions) that work with that data into a single unit known as a class. This protective layer around the data allows it to maintain its integrity and prevents unauthorized access.</p> <p>For example, imagine a coffee machine. A coffee machine has a grinder, brewer, and many other internal components that allows it to function. But you don't need to know how it works, you only need to know which buttons to press to get your coffee. This is similar to how it works in OOP.</p>"},{"location":"tutorials/best-practices/encapsulation/#why-encapsulation","title":"Why Encapsulation?","text":"<ul> <li>Data Protection: By making the data private, you hide it from the outside world. Therefore, you protect it from accidental or intentional modifications from outside the class, ensuring its integrity. It also protects sensitive information.</li> <li>Data Validation: It allows you to ensure that the given data to the class is valid, and thus allowing for a safer system.</li> <li>Increased Maintainability: By controlling the access, any internal implementation changes are less likely to effect other external parts of the program.</li> <li>Increased Flexibility: It also allows for a cleaner interface, and due to the internal parts being private, the interface can be reused effectively. </li> </ul>"},{"location":"tutorials/best-practices/encapsulation/#implementation","title":"Implementation","text":"<pre><code>local class = ClassPP.class\n\nlocal Student = class \"Student\" {\n    Public = {\n        -- Getter method for name\n        getName = function(self)\n            return self.Name\n        end,\n\n        -- Setter method for name\n        setName = function(self, name)\n            self.Name = name\n        end,\n\n        -- Getter method for age\n        getAge = function(self)\n            return self.Age\n        end,\n\n        -- Setter method for age\n        setAge = function(self, age)\n            if age &gt; 0 then\n                self.Age = age\n            end\n        end\n    },\n\n    Private = {\n        Name = \"\",\n        Age = 0\n    }\n}\n</code></pre> <p>In the example above, the <code>Student</code> class has private members called \"Name\" and \"Age\". The setter for the member \"Age\" includes a basic validation check. Using these getter and setter methods, we are able to access the values for these members.</p>"},{"location":"tutorials/best-practices/encapsulation/#tips","title":"Tips","text":"<p>If you want to implement encapsulation, make sure all the important data are set as private, to protect them from external modification. Using getter and setter methods for that data will allow for a much safer experience while allowing flexibility in changing the internal implementation. Like in the example on the previous section, also implementing validation checks will greatly improve data integrity.</p>"},{"location":"tutorials/best-practices/errorHandling/","title":"Error Handling","text":"<p>(Coming Soon)</p>"},{"location":"tutorials/best-practices/optimization/","title":"Optimization","text":"<p>(Coming Soon)</p>"},{"location":"tutorials/best-practices/polymorphism/","title":"Polymorphism","text":"<p>In simple terms, Polymorphism stands for \"many forms\", it's one of the core concepts of OOP. It refers to situations where something occurs in several different forms, and describes the concept that you can access objects of different types through the same interface.</p> <p>Function Overloading, Operator Overloading, and Inheritance belong to this concept, for example with inheritance, we can create derived classes that have the same method name, but all do different things. Or with function overloading, every function has different arguments and does a different thing, but all share the same name. It provides flexibility, and extensibility.</p>"},{"location":"tutorials/best-practices/polymorphism/#inheritance-example","title":"Inheritance Example","text":"<pre><code>local class = ClassPP.class\n\nlocal Animal = class \"Animal\" {\n    Public = {\n        animalSound = function(self)\n            print(\"The animal makes a sound\")\n        end\n    }\n}\n\n-- Derived class\nlocal Pig = class \"Pig\" (Animal, nil) {\n    Public = {\n        animalSound = function(self)\n            print(\"The pig says: oink oink\")\n        end\n    }\n}\n\n-- Derived class\nlocal Dog = class \"Dog\" (Animal, nil) {\n    Public = {\n        animalSound = function(self)\n            print(\"The dog says: woof woof\")\n        end\n    }\n}\n</code></pre>"},{"location":"tutorials/best-practices/polymorphism/#function-overloading-example","title":"Function Overloading Example","text":"<pre><code>local class = ClassPP.class\n\nlocal Test = class \"Test\" {}\nTest.overload(\"Public\", \"Display\", {\n    function(self, number1)\n        print(\"Number: \", number1)\n    end,\n    function(self, number1, number2)\n        print(\"Numbers: \", number1, number2)\n    end\n})\n</code></pre>"}]}