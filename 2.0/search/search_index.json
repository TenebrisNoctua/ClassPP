{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#classppTitle","title":"Overload your Classes.","text":"<p>     Tired of the traditional class system on Roblox?     Tired of learning complex systems, and wish for something easier?     Wish to do OOP in the right way, like in many languages such as C++? </p> <p>     Then you're in the right place.     Introducing: Class++.     Classes were never this easy to create, and advanced before on Roblox. </p> Getting Started Download"},{"location":"api-reference/","title":"API Reference","text":"<p>Welcome to the API Reference section of Class++ !  This section is more technical, and is not recommended for beginners. Check out the tutorials for a guided experience!</p> <p>You can use the left bar to find the API members grouped by their category. Additionally, you can use the search bar to find a specific API member.</p>"},{"location":"api-reference/class-functions/main/abstract/","title":"abstract :class","text":"<p><pre><code>function classpp.abstract(classTable: {class}): class\n</code></pre> Marks the given <code>class</code> or <code>class</code>es as abstract. If given multiple, then the first class will be returned.</p>"},{"location":"api-reference/class-functions/main/abstract/#default-syntax","title":"Default Syntax","text":"<pre><code>local Car = abstract { class \"Car\" {\n    Public = {\n        ...\n    },\n    ...\n}}\n</code></pre>"},{"location":"api-reference/class-functions/main/abstract/#without-syntax-sugar","title":"Without Syntax Sugar","text":"<pre><code>local Car = abstract({class(\"Car\")({\n    Public = {\n        ...\n    },\n    ...\n})})\n</code></pre>"},{"location":"api-reference/class-functions/main/abstract/#parameters","title":"Parameters","text":"<p> classTable: {class} The desired <code>class</code> or <code>class</code>es to be set to abstract. </p>"},{"location":"api-reference/class-functions/main/abstract/#returns","title":"Returns","text":"<p> class"},{"location":"api-reference/class-functions/main/class/","title":"class :class","text":"<pre><code>function classpp.class(className: string): (classData: classData) -&gt; class\n</code></pre> <p>Creates a new <code>class</code> with the given <code>classData</code> table.</p>"},{"location":"api-reference/class-functions/main/class/#default-syntax","title":"Default Syntax","text":"<pre><code>local Class = class \"Class\" {\n    constructor = function(self)\n        ...\n    end,\n    destructor = function(self)\n        ...\n    end,\n    Public = {\n        ...\n    },\n    Private = {\n        ...\n    },\n    Protected = {\n        ...\n    },\n    Friend = {\n        ...\n    }\n}\n</code></pre>"},{"location":"api-reference/class-functions/main/class/#without-syntax-sugar","title":"Without Syntax Sugar","text":"<pre><code>local Class = class(\"Class\")({\n    constructor = function(self)\n        ...\n    end,\n    destructor = function(self)\n        ...\n    end,\n    Public = {\n        ...\n    },\n    Private = {\n        ...\n    },\n    Protected = {\n        ...\n    },\n    Friend = {\n        ...\n    }\n})\n</code></pre>"},{"location":"api-reference/class-functions/main/class/#parameters","title":"Parameters","text":"<p> className: string An unique name for the <code>class</code>. inheritedClasses: ...class The <code>class</code>es the created <code>class</code> will inherit from. (Optional) classData: classData The <code>classData</code> table that contains the data such as access specifiers for the <code>class</code>."},{"location":"api-reference/class-functions/main/class/#returns","title":"Returns","text":"<p> class"},{"location":"api-reference/class-functions/main/final/","title":"final :class","text":"<pre><code>function classpp.final(classTable: {class}): class\n</code></pre> <p>Marks the given <code>class</code> or <code>class</code>es as final. If given multiple, then the first class will be returned.</p>"},{"location":"api-reference/class-functions/main/final/#default-syntax","title":"Default Syntax","text":"<pre><code>local Car = final { class \"Car\" {\n    Public = {\n        ...\n    },\n    ...\n}}\n</code></pre>"},{"location":"api-reference/class-functions/main/final/#without-syntax-sugar","title":"Without Syntax Sugar","text":"<pre><code>local Car = final({class(\"Car\")({\n    Public = {\n        ...\n    },\n    ...\n})})\n</code></pre>"},{"location":"api-reference/class-functions/main/final/#parameters","title":"Parameters","text":"<p> classTable: {class} The desired <code>class</code> or <code>class</code>es to be set to final. </p>"},{"location":"api-reference/class-functions/main/final/#returns","title":"Returns","text":"<p> class"},{"location":"api-reference/class-functions/main/getClass/","title":"getClass :class","text":"<pre><code>function classpp.getClass(className: string): class\n</code></pre> <p>Returns the <code>class</code> with the given <code>className</code>, if it exists.</p>"},{"location":"api-reference/class-functions/main/getClass/#default-syntax","title":"Default syntax","text":"<pre><code>local Class = ClassPP.getClass(\"Class\")\n</code></pre>"},{"location":"api-reference/class-functions/main/getClass/#parameters","title":"Parameters","text":"<p> className: string The name of the desired <code>class</code>. </p>"},{"location":"api-reference/class-functions/main/getClass/#returns","title":"Returns","text":"<p> class"},{"location":"api-reference/class-functions/type/type/","title":"type :string","text":"<pre><code>function Type.type(object: any): string\n</code></pre> <p>Returns the true type of the given <code>object</code>. Behaves the same as the built-in <code>type()</code> function, but with additional support for <code>class</code>es and <code>object</code>s.</p>"},{"location":"api-reference/class-functions/type/type/#default-syntax","title":"Default syntax","text":"<pre><code>local objectType = ClassPP.Type.type(object)\n</code></pre>"},{"location":"api-reference/class-functions/type/type/#parameters","title":"Parameters","text":"<p> object: object The <code>object</code>. </p>"},{"location":"api-reference/class-functions/type/type/#returns","title":"Returns","text":"<p> string"},{"location":"api-reference/class-functions/type/typeof/","title":"typeof :string","text":"<pre><code>function Type.typeof(object: any): string\n</code></pre> <p>Returns the type of the given <code>object</code>. Behaves the same as the built-in Roblox <code>typeof()</code> function, but with additional support for <code>class</code>es and <code>object</code>s.</p>"},{"location":"api-reference/class-functions/type/typeof/#default-syntax","title":"Default syntax","text":"<pre><code>local objectType = ClassPP.Type.typeof(object)\n</code></pre>"},{"location":"api-reference/class-functions/type/typeof/#parameters","title":"Parameters","text":"<p> object: object The <code>object</code>. </p>"},{"location":"api-reference/class-functions/type/typeof/#returns","title":"Returns","text":"<p> string"},{"location":"api-reference/class-functions/utility/checkFriendship/","title":"checkFriendship :boolean","text":"<pre><code>function Util.checkFriendship(class: class, methodName: string, method: () -&gt; (), classes: {[string]: class}): boolean\n</code></pre> <p>This function checks if the given <code>method</code> and it's <code>methodName</code> is in the given <code>class</code>'s <code>Friend</code> access specifier.</p>"},{"location":"api-reference/class-functions/utility/checkFriendship/#default-syntax","title":"Default syntax","text":"<pre><code>local isAFriend = ClassPP.Util.checkFriendship(class, methodName, method, classes)\n</code></pre>"},{"location":"api-reference/class-functions/utility/checkFriendship/#parameters","title":"Parameters","text":"<p> class: class The <code>class</code> that the check will be made from. methodName: string The name of the given <code>method</code>. class: class The <code>method</code> that will be checked. classes: {[string]: class} A table that contains all of the created <code>class</code>es. Since a <code>class</code> can also be inserted to the <code>Friend</code> access specifier through a <code>string</code> that contains the <code>class</code>'s name, this table is used to find the <code>class</code>es set with this method. </p>"},{"location":"api-reference/class-functions/utility/checkFriendship/#returns","title":"Returns","text":"<p> boolean"},{"location":"api-reference/class-functions/utility/checkInheritance/","title":"checkInheritance :boolean","text":"<pre><code>function Util.checkInheritance(class: class, classOrMethod: class | () -&gt; ()): boolean\n</code></pre> <p>If the <code>classOrMethod</code> is a <code>class</code>, the function checks if the given <code>class</code> has been inherited from <code>classOrMethod</code>, or if the <code>classOrMethod</code> is a method, then it simply checks if any of the classes that the given <code>class</code> inherits from contains the method.</p>"},{"location":"api-reference/class-functions/utility/checkInheritance/#default-syntax","title":"Default syntax","text":"<pre><code>local isInherited = ClassPP.Util.checkInheritance(classOne, classTwo) -- For classes\nlocal isInherited = ClassPP.Util.checkInheritance(class, method) -- For methods\n</code></pre>"},{"location":"api-reference/class-functions/utility/checkInheritance/#parameters","title":"Parameters","text":"<p> class: class The <code>class</code> that the check will be made from. classOrMethod: class | () -&gt;() The <code>class</code> or the <code>method</code> that will be checked. </p>"},{"location":"api-reference/class-functions/utility/checkInheritance/#returns","title":"Returns","text":"<p> boolean"},{"location":"api-reference/class-functions/utility/inClassScope/","title":"inClassScope :boolean","text":"<pre><code>function Util.inClassScope(class: class, includeInherited: boolean, includeFriend: boolean, classes: {[string]: class}?, defaultLevel: number?): boolean\n</code></pre> <p>This function checks if the current thread is allowed to access a specific <code>class</code> property from a certain access specifier.</p>"},{"location":"api-reference/class-functions/utility/inClassScope/#default-syntax","title":"Default syntax","text":"<pre><code>local isAllowed = Util.inClassScope(class, false, true, Classes) -- For the Private access specifier\n</code></pre>"},{"location":"api-reference/class-functions/utility/inClassScope/#parameters","title":"Parameters","text":"<p> class: class The <code>class</code> that the check will be made from. includeInherited: boolean Determines if the inherited <code>class</code>es can access. includeFriend: boolean Determines if the friend <code>class</code>es can access. classes: {[string]: class} A table that contains classes. If <code>includeFriend</code> is set to <code>true</code>, this table will be given to the Util.checkFriendship function. defaultLevel: number Determines the default call stack level the function will start doing the checks on. </p>"},{"location":"api-reference/class-functions/utility/inClassScope/#returns","title":"Returns","text":"<p> boolean"},{"location":"api-reference/data-types/class/","title":"Class","text":"<p>A <code>class</code> object created from the <code>class()</code> function. Contains all of the members given from the <code>classData</code>.</p> Summary Properties <ul> <li>Name: An unique identifier of the <code>class</code>.</li> <li>Inherits: A table that contains classes that the <code>class</code> inherits from.</li> <li>Friends: A table that contains functions or clases that can access the <code>Private</code> and the <code>Protected</code> members of the <code>class</code>. </li> <li>Statics:  A table that contains the static members of the <code>class</code>. These members can only be called through the <code>class</code> object.</li> </ul> Methods <ul> <li>new:  Returns a new <code>object</code> that contains all of the members given from the <code>class</code>.</li> <li>extends: Used to create a new <code>class</code> that inherits the <code>class</code> it's been created from. (Deprecated)</li> <li>overload: Creates an overloaded function with the given access specifier, name and the function table, and saves it to the <code>class</code>'s <code>classData</code>.</li> </ul>"},{"location":"api-reference/data-types/class/#properties","title":"Properties","text":""},{"location":"api-reference/data-types/class/#name-string","title":"Name              : string","text":"<p>This is an unique identifier of the <code>class</code>. Using the <code>getClass()</code> function with this property will retrieve the desired <code>class</code>. Since names are unique, for every class, you have to use a different name.</p>"},{"location":"api-reference/data-types/class/#inherits-class-read-only","title":"Inherits              : {class}      Read Only","text":"<p>This table contains all the classes that the <code>class</code> is inheriting from. </p>"},{"location":"api-reference/data-types/class/#friends-class-read-only","title":"Friends              : {class}      Read Only","text":"<p>This table contains all the functions and the classes that can access all of the <code>Public</code> and <code>Protected</code> members of the <code>class</code>.</p>"},{"location":"api-reference/data-types/class/#statics-string-any-read-only","title":"Statics              : {[string]: any}      Read Only","text":"<p>This table contains all the members that are static, meaning they only belong to the <code>class</code>. These members won't replicate to the  objects, and can only be called through the <code>class</code> object.</p>"},{"location":"api-reference/data-types/class/#methods","title":"Methods","text":""},{"location":"api-reference/data-types/class/#new-object","title":"new              : object","text":"<p>Creates and returns a new <code>object</code> that contains all of the members given from the <code>class</code>.</p>"},{"location":"api-reference/data-types/class/#returns","title":"Returns","text":"<p> object </p>"},{"location":"api-reference/data-types/class/#extends-void","title":"extends              : void","text":"<p>Used to create and return a new <code>class</code> that inherits the <code>class</code> it's been created from.</p> <p>Deprecated</p> <p>This method has been deprecated and should not be used for new work. Instead, use the <code>class</code> method.</p>"},{"location":"api-reference/data-types/class/#overload-void","title":"overload              : void","text":"<p>Creates an overloaded function with the given parameters, and saves it to the <code>class</code>'s <code>classData</code> table.</p>"},{"location":"api-reference/data-types/class/#parameters","title":"Parameters","text":"<p> accessSpecifier: string The access specifier of the overloaded function. name: string The name of the overloaded function. functionTable: {(...any) -&gt; (any)} The function table that contains all the functions with different amount of arguments for the overloaded function. </p>"},{"location":"api-reference/data-types/class/#returns_1","title":"Returns","text":"<p> void </p>"},{"location":"api-reference/data-types/class/#static-void","title":"static              : void","text":"<p>Creates a new static member with the given parameters, and saves it to the <code>class</code>'s <code>Statics</code> table. These members do not replicate to the objects, as they belong to the <code>class</code>. </p>"},{"location":"api-reference/data-types/class/#parameters_1","title":"Parameters","text":"<p> accessSpecifier: string The access specifier of the static member. name: string The name of the static member. property: any The property that will be saved to the static member. This property can then be accessed through indexing the <code>class</code> with the member name, such as: <code>class.memberName.property</code>. (Or <code>class.memberName.p</code>) </p>"},{"location":"api-reference/data-types/class/#returns_2","title":"Returns","text":"<p> void </p>"},{"location":"api-reference/data-types/object/","title":"Object","text":"<p>An <code>object</code> created from the <code>class.new()</code> function. Contains all of the members given from the <code>class</code> object.</p> <p>Warning</p> <p><code>object</code>s act as a proxy, as they belong to the base type <code>userdata</code>. They allow access to members in the <code>objectData</code>, but they cannot be changed. This is to make access-specifiers work in the best way possible.</p> Summary Properties <ul> <li>__locked: Indicates if the <code>object</code> is locked.</li> <li>__type: Indicates the type of the <code>object</code>.</li> <li>__objtype: Indicates the <code>class</code> type of the <code>object</code>.</li> </ul> Methods <ul> <li>constructor: The constructor function of the <code>object</code>, if it exists. Cannot be directly called.</li> <li>destructor: The destructor function of the <code>object</code>, if it exists. Cannot be directly called.</li> <li>Destroy: Calls the <code>destructor</code> function, destroys all the instances inside the <code>objectData</code> and clears it, and sets the <code>__locked</code> property to <code>true</code>.</li> <li>super: Calls the method with the same name of the function that it's been called from in the parent <code>class</code>, if it exists.</li> </ul>"},{"location":"api-reference/data-types/object/#properties","title":"Properties","text":""},{"location":"api-reference/data-types/object/#__locked-boolean-internal","title":"__locked              : boolean      Internal","text":"<p>Indicates if an <code>object</code> has been locked. If set to true, the <code>object</code>'s metamethods will no longer work and all the members will become unaccessable. </p>"},{"location":"api-reference/data-types/object/#__type-string-internal","title":"__type              : string      Internal","text":"<p>Indicates the type of the <code>object</code>. For <code>object</code>s created from <code>class.new()</code>, it will always be \"Object\".</p>"},{"location":"api-reference/data-types/object/#__objtype-string-internal","title":"__objtype              : string      Internal","text":"<p>Indicates the <code>class</code> type of the <code>object</code>. Can be used to determine which <code>class</code> the <code>object</code> belongs to by using the <code>Type.typeof()</code> function.</p>"},{"location":"api-reference/data-types/object/#methods","title":"Methods","text":""},{"location":"api-reference/data-types/object/#constructor-void-internal","title":"constructor              : void      Internal","text":"<p>The <code>constructor</code> function of the <code>object</code>, if it has been set in the <code>classData</code> table. This function is internal, and it will only be called when the <code>object</code> is created by using the <code>class.new()</code> function.</p>"},{"location":"api-reference/data-types/object/#returns","title":"Returns","text":"<p> void </p>"},{"location":"api-reference/data-types/object/#destructor-void-internal","title":"destructor              : void      Internal","text":"<p>The <code>destructor</code> function of the <code>object</code>, if it has been set in the <code>classData</code> table. This function accepts no parameters and is internal, it will only be called when <code>object:Destroy()</code> is called. </p>"},{"location":"api-reference/data-types/object/#returns_1","title":"Returns","text":"<p> void </p>"},{"location":"api-reference/data-types/object/#destroy-void","title":"Destroy              : void","text":"<p>Calling this method will destroy and clean the <code>object</code>. This method will first trigger the <code>destructor</code> function, then after, it will clear the internal <code>objectData</code> table and set the <code>__locked</code> property of the <code>object</code> to <code>true</code>. Instances inside <code>objectData</code> will automatically be destroyed and cleared too.</p> <p>After this function runs, the <code>object</code> will no longer be accessible in any way, so make sure to remove all references to the <code>object</code> to allow for the garbage collector to clear it. This prevents memory leaks.</p>"},{"location":"api-reference/data-types/object/#returns_2","title":"Returns","text":"<p> void </p>"},{"location":"api-reference/data-types/object/#super-any","title":"super              : any","text":"<p>This method allows you to refer to the parent <code>class</code>'s methods. Calling this method will call the function with the same name as the function it's been called from in the parent <code>class</code>, if it exists, and return the result.</p> <p>Warning</p> <p><code>super</code> does not support being called in <code>class</code>es created from multi-inheritance, as it would create ambiguity. It also does not support calling functions that are defined in the <code>Private</code> access-specifier in the parent <code>class</code>.</p>"},{"location":"api-reference/general/autoObjectDestruction/","title":"autoObjectDestruction :boolean","text":"<p>This property indicates whether or not a created <code>object</code> will automatically be destroyed when its reference has been garbage collected. It is set to <code>true</code> by default, and allows Class++ to automatically call the <code>destructor</code> function (if defined) of an <code>object</code> automatically.</p> <p>It can be set to <code>false</code> if desired, however, you will have to manually destroy every <code>object</code> if you do, to prevent memory leaks.</p>"},{"location":"api-reference/general/errors/","title":"Errors","text":"<p>When Class++ displays an error message to the output, it will have a short ID at the end. This allows you to identify what kind of error or message that is.</p> <p>You can use that ID to find the details about that error or message down below.</p>"},{"location":"api-reference/general/errors/#attempttomodifyreadonlytable","title":"attemptToModifyReadOnlyTable","text":"<pre><code>Cannot modify a read only table.\n</code></pre> <p>You've attempted modify a read-only table within Class++. This usually occurs when you try to modify the <code>Inherits</code>, <code>Friends</code> and <code>Statics</code> tables of a <code>class</code>.</p>"},{"location":"api-reference/general/errors/#attempttocreateobjectfromabstractclass","title":"attemptToCreateObjectFromAbstractClass","text":"<pre><code>Cannot create an object from an abstracted class.\n</code></pre> <p>You tried to create an <code>object</code> from an abstract <code>class</code>. Abstract classes are not meant to create objects from, rather, they are meant to be a base-class that a <code>class</code> inherits from.</p>"},{"location":"api-reference/general/errors/#attempttoextendafinalclass","title":"attemptToExtendAFinalClass","text":"<pre><code>Cannot create an inherited class from a final class.\n</code></pre> <p>You tried to create a <code>class</code> from a final <code>class</code>. Final classes are not meant to be inherited from.</p>"},{"location":"api-reference/general/errors/#cannotcallfunctionerror","title":"cannotCallFunctionError","text":"<pre><code>Cannot call function ... directly.\n</code></pre> <p>You've tried to call a function within a <code>class</code> without creating an <code>object</code>. Class functions are not meant to be used directly, rather, they are to be used from objects. (Excluding static members.)</p>"},{"location":"api-reference/general/errors/#cannotcallfunctionfrom","title":"cannotCallFunctionFrom","text":"<pre><code>Cannot call function ... from ...\n</code></pre> <p>You've tried to call a function within an <code>object</code> that cannot be called within certain functions, such as <code>super()</code> in <code>destructor</code>.</p>"},{"location":"api-reference/general/errors/#cannotfindbaseclassmethod","title":"cannotFindBaseClassMethod","text":"<pre><code>Property ... cannot be found or is not a function in the base class ...\n</code></pre> <p>You've tried to call a property with <code>super()</code> in the base <code>class</code> that cannot be found, or wasn't a function.</p>"},{"location":"api-reference/general/errors/#classalreadyexists","title":"classAlreadyExists","text":"<pre><code>Class ... already exists.\n</code></pre> <p>You've tried to create a <code>class</code> that already has been created with the same name. Consider changing the name of the new <code>class</code>.</p>"},{"location":"api-reference/general/errors/#classclassdatainternal","title":"classClassDataInternal","text":"<pre><code>The property classData of the class ... is Internal. It cannot be used.\n</code></pre> <p>You've attempted to access the <code>classData</code> property of a <code>class</code> directly. This property is meant to be used internally, and is not meant for external use. This property only shows up in the auto-complete to support type-checking in certain cases.</p>"},{"location":"api-reference/general/errors/#classdatanottable","title":"classDataNotTable","text":"<pre><code>Given classData value for the class ... is not a table.\n</code></pre> <p>You've given a <code>classData</code> value that is not a table to the <code>class</code> function. The <code>class</code> function only takes a table as its <code>classData</code> parameter.</p>"},{"location":"api-reference/general/errors/#classdatacontainsmetatable","title":"classDataContainsMetatable","text":"<pre><code>Given classData value for the class ... contains a metatable.\n</code></pre> <p>You've given a <code>classData</code> value that contains a metatable attached to it. For security and performance reasons, <code>classData</code> parameter only takes a raw table without any metatables attached to it.</p>"},{"location":"api-reference/general/errors/#classmembercannotsettonil","title":"classMemberCannotSetToNil","text":"<pre><code>Class members cannot be set to nil.\n</code></pre> <p>You've attempted to set a class member within the <code>object</code> to nil. Setting member values to nil causes certain bugs to happen (due to the nature of dictionaries), so it is not allowed to set them to <code>nil.</code> Consider setting it to a value such as <code>false</code> to indicate that it is no longer in use.</p>"},{"location":"api-reference/general/errors/#classmembernotfound","title":"classMemberNotFound","text":"<pre><code>This class has no member named ...\n</code></pre> <p>You've tried to index the <code>object</code> with a member that does not exist within the <code>classData</code> table. Members can only be added or removed through changing the <code>classData</code> table given to the <code>class</code> function.</p>"},{"location":"api-reference/general/errors/#classnamenotstring","title":"classNameNotString","text":"<pre><code>Class name is not a string or is nil.\n</code></pre> <p>The <code>class</code> function expected a <code>string</code> as it's name, but you provided something else. A <code>class</code>'s name can only be a <code>string</code>. </p>"},{"location":"api-reference/general/errors/#classnotfound","title":"classNotFound","text":"<pre><code>A class with the given name cannot be found.\n</code></pre> <p>A <code>class</code> cannot be found with the provided name argument. Make sure the name is correct, or if the <code>class</code> actually exists.</p>"},{"location":"api-reference/general/errors/#classnomatchingfunctionerror","title":"classNoMatchingFunctionError","text":"<pre><code>No match for ... function in this class.\n</code></pre> <p>You've used an operator on an <code>object</code> which had no overloads set for it.</p>"},{"location":"api-reference/general/errors/#classobjectlocked","title":"classObjectLocked","text":"<pre><code>This class object has been locked.\n</code></pre> <p>You've tried to use an <code>object</code> after it's been locked.</p>"},{"location":"api-reference/general/errors/#classpropertyisprivate","title":"classPropertyIsPrivate","text":"<pre><code>Property ... is private in this class.\n</code></pre> <p>You've tried to access a private member of an <code>object</code> outside of a class function.</p>"},{"location":"api-reference/general/errors/#classpropertyisprotected","title":"classPropertyIsProtected","text":"<pre><code>Property ... is protected in this class.\n</code></pre> <p>You've tried to access a protected member of an <code>object</code> outside of a class function.</p>"},{"location":"api-reference/general/errors/#classpropertyisinternal","title":"classPropertyIsInternal","text":"<pre><code>Property ... is internal in this class. You cannot access it.\n</code></pre> <p>You've tried to access an internal member of an <code>object</code>. Internal members are not accessible.</p>"},{"location":"api-reference/general/errors/#classpropertyredeclaration","title":"classPropertyRedeclaration","text":"<pre><code>Cannot redeclare property ...\n</code></pre> <p>You've tried to declare a property that has already been declared in another access-specifier. You can only declare a member in one access-specifier.</p>"},{"location":"api-reference/general/errors/#expectedfunctionerror","title":"expectedFunctionError","text":"<pre><code>Expected function, got: ...\n</code></pre> <p>The <code>functionsTable</code> that you provided to <code>class.overload</code> function had a value that wasn't a function.</p>"},{"location":"api-reference/general/errors/#extendsdeprecated","title":"extendsDeprecated","text":"<pre><code>Extends is now deprecated. Use the \"class\" function instead.\n</code></pre> <p>You've tried to use the now deprecated <code>extends</code> function for inheritance. See the discussion <code>#4</code> for more info.</p>"},{"location":"api-reference/general/errors/#invalidaccessspecifiererror","title":"invalidAccessSpecifierError","text":"<pre><code>Given value is not a valid access specifier.\n</code></pre> <p>You've provided a value that wasn't a valid access specifier. Make sure the given <code>string</code> contains a valid access-specifier. </p>"},{"location":"api-reference/general/errors/#invalidaccessspecifierinclassdata","title":"invalidAccessSpecifierInClassData","text":"<pre><code>Given classData value for the class ... contains invalid access specifier(s) or function(s).\n</code></pre> <p>You've given a <code>classData</code> value that contains invalid access-specifiers or functions. Make sure the access-specifier or function names are correct.</p>"},{"location":"api-reference/general/errors/#invaliddestructorcall","title":"invalidDestructorCall","text":"<pre><code>Cannot call Destroy without an object argument. Try calling the function with the ':' operator.\n</code></pre> <p>You've tried to call the <code>Destroy()</code> without providing the <code>object</code> as its first argument. Calling it with a ':' like <code>:Destroy()</code>, passes the <code>object</code> argument automatically.</p>"},{"location":"api-reference/general/errors/#invalidmodifierargument","title":"invalidModifierArgument","text":"<pre><code>Given argument is not a class table.\n</code></pre> <p>You've given a value to a modifier function that wasn't a table containing classes.</p>"},{"location":"api-reference/general/errors/#invalidpropertydecleration","title":"invalidPropertyDecleration","text":"<pre><code>Cannot create reserved property ...\n</code></pre> <p>You've tried to create a reserved property in a <code>class</code>. Some property names are reserved for certain functions that come by default for every <code>object</code>, so you cannot declare them inside the <code>classData</code> value.</p>"},{"location":"api-reference/general/errors/#invalidsupercall","title":"invalidSuperCall","text":"<pre><code>Cannot call super in a multi-inherited class, or in a non-inherited class.\n</code></pre> <p>You've tried to call the <code>super()</code> function from a <code>class</code> that either wasn't inheriting from another <code>class</code>, or it was inheriting from multiple <code>class</code>es. </p>"},{"location":"api-reference/general/errors/#illegalmodifiercombination","title":"illegalModifierCombination","text":"<pre><code>Cannot create an illegal combination of modifiers: ...\n</code></pre> <p>You've tried to create an illegal combination of modifiers. Certain modifiers have opposite functionality, so combining them is not possible.</p>"},{"location":"api-reference/general/errors/#nonnativeoperatorcall","title":"nonNativeOperatorCall","text":"<pre><code>Operator function ... cannot be called without its operator.\n</code></pre> <p>You've tried to call an operator function without its operator. Operator functions are meant to be called with their operators.</p>"},{"location":"api-reference/general/errors/#overloadfunctionargumentmismatch","title":"overloadfunctionArgumentMismatch","text":"<pre><code>A function to handle the given number of arguments ... have not been provided for the overloaded function: ...\n</code></pre> <p>You haven't provided a function to the <code>functionsTable</code> to handle the given number of arguments for an overloaded function.</p>"},{"location":"api-reference/general/errors/#overloadfunctionnamenotset","title":"overloadfunctionNameNotSet","text":"<pre><code>A function name has not been set for the overloaded function.\n</code></pre> <p>You haven't provided a name for the overloaded function.</p>"},{"location":"api-reference/general/errors/#overloadfunctiontablenotgiven","title":"overloadfunctionTableNotGiven","text":"<pre><code>A function table has not been given for the overloaded function.\n</code></pre> <p>You haven't provided a <code>functionsTable</code> for the overloaded function.</p>"},{"location":"api-reference/general/errors/#staticmembernamenotset","title":"staticMemberNameNotSet","text":"<pre><code>A name has not been set for the static member.\n</code></pre> <p>You haven't provided a name for the static member.</p>"},{"location":"api-reference/general/errors/#typeofobjectnotfound","title":"typeofObjectNotFound","text":"<pre><code>The given object's type cannot be found.\n</code></pre> <p>The provided object's type cannot be found.</p>"},{"location":"api-reference/general/errors/#unhandlederror","title":"unhandledError","text":"<pre><code>An unhandled error occured in \"...\": ...\n</code></pre> <p>An unhandled error has occured in a specific function given to Class++. This error does not halt the execution of the thread, so be mindful of the bugs that may occur in your code.</p>"},{"location":"api-reference/general/errors/#unknownerror","title":"unknownError","text":"<pre><code>An unknown error has occured.\n</code></pre> <p>Class++ ran into a problem, but it cannot associate it with a valid error type. This is meant to be a fallback error, and may only occur if the internal code isn't running properly.</p>"},{"location":"api-reference/general/version/","title":"version :version","text":"<p>The version of the Class++ source code.  If <code>beta</code> is true, then the version is beta and is seperate from the release versions.</p>"},{"location":"api-reference/types/classData/","title":"classData","text":"<pre><code>export type classData = {\n    constructor: (any, ...any) -&gt; ()?,\n    destructor: (any) -&gt; ()?,\n    Public: {[string]: any}?,\n    Private: {[string]: any}?,\n    Protected: {[string]: any}?,\n    Friend: {any}?\n}\n</code></pre> <p>The <code>classData</code> table that is given to the <code>class()</code> function that contains data about the desired <code>class</code>.</p>"},{"location":"api-reference/types/classData/#properties","title":"Properties","text":""},{"location":"api-reference/types/classData/#constructor-self-any-any-","title":"constructor              : (self: any, ...any) -&gt; ()?","text":"<p>The <code>constructor</code> function that will be called when an <code>object</code> gets created.</p>"},{"location":"api-reference/types/classData/#destructor-self-any-","title":"destructor              : (self: any) -&gt; ()?","text":"<p>The <code>destructor</code> function that will be called when an <code>object</code> gets destroyed.</p>"},{"location":"api-reference/types/classData/#public-string-any","title":"Public              : {[string]: any}?","text":"<p>The access specifier that contains properties that can be globally accessable.</p>"},{"location":"api-reference/types/classData/#private-string-any","title":"Private              : {[string]: any}?","text":"<p>The access specifier that contains properties that can only be accessed inside the <code>class</code>.</p>"},{"location":"api-reference/types/classData/#protected-string-any","title":"Protected              : {[string]: any}?","text":"<p>The access specifier that contains properties that can only be accessed inside the <code>class</code> and inherited classes.</p>"},{"location":"api-reference/types/classData/#friend-any","title":"Friend              : {any}?","text":"<p>The access specifier that contains functions and classes that can access the <code>class</code>'s <code>Private</code> properties.</p>"},{"location":"api-reference/types/version/","title":"version","text":"<pre><code>export type version = {\n    major: number,\n    minor: number,\n    patch: number,\n    beta: boolean\n}\n</code></pre> <p>Describes a version of Class++ source code.</p>"},{"location":"api-reference/types/version/#properties","title":"Properties","text":""},{"location":"api-reference/types/version/#major-number","title":"major              : number","text":"<p>The major version number. Two versions with different major numbers are expected to be incompatible, and have breaking changes.</p>"},{"location":"api-reference/types/version/#minor-number","title":"minor              : number","text":"<p>The minor version number. Two versions with different minor, but not major numbers are expected to be mostly compatible, but may have certain changes.</p>"},{"location":"api-reference/types/version/#patch-number","title":"patch              : number","text":"<p>The patch version number. Two versions with different patch, but not major or minor numbers are expected to be highly compatible. The patch version number only increases when bug fixes or very minor changes have been made.</p>"},{"location":"api-reference/types/version/#beta-number","title":"beta              : number","text":"<p>Describes whether or not the version is beta. If <code>true</code>, then the version is seperate from release versions, and may not be available in multiple platforms.</p>"},{"location":"tutorials/","title":"Getting Started","text":"<p>Welcome to the Class++ tutorial section! In here, you will learn how to use and build systems with Class++.</p>"},{"location":"tutorials/#what-you-should-know","title":"What You Should Know","text":"<p>While you don't need to be an expert programmer to use Class++, you should still have:</p> <ul> <li>Basic knowledge of Luau.<ul> <li>While not a requirement, you should also have basic knowledge of metatables.</li> </ul> </li> <li>Basic understanding on the concept of OOP (Object Oriented Programming).</li> </ul> <p>Some tutorials may seem harder or easier depending on your existing knowledge. It is recommended that you follow each one in order, and try the given examples on your own.</p>"},{"location":"tutorials/#installation","title":"Installation","text":""},{"location":"tutorials/#installing-via-roblox","title":"Installing via Roblox","text":"<p>If you are creating experiences in Roblox, and you wish to install Class++, you can either:</p> <ul> <li> <p>Download the <code>.rbxm</code> file that contains the source code from the latest release.</p> <ul> <li>1: In Roblox Studio, right click the location (e.g, <code>ReplicatedStorage</code>) that you wish to insert this file to.</li> <li>2: Go to \"Insert &gt; Import Roblox Model\".</li> <li>3: Select the <code>ClassPP.rbxm</code> file that you've just downloaded.</li> </ul> </li> <li> <p>Get the source code from Roblox Creator Store.</p> <ul> <li>1: In Roblox Studio, open Toolbox.</li> <li>2: Go to \"Inventory &gt; Models\".</li> <li>3: Select the \"Class++\" item on your inventory. It should automatically be inserted into <code>Workspace</code>.</li> </ul> </li> </ul>"},{"location":"tutorials/#installing-as-source-code","title":"Installing as Source Code","text":"<p>If you're using pure Luau, or if you're just synchronising external files into Roblox Studio, then you can use the source code instead.</p> <p>To do this, you can either:</p> <ul> <li> <p>From the latest release, download the source code as zip.</p> <ul> <li>1: Inside the zip, copy the <code>src</code> folder.</li> <li>2: Paste this folder into wherever you please, for example, inside another folder named <code>lib</code> or <code>shared</code>.</li> <li>3: Rename this pasted <code>src</code> folder as \"ClassPP\".</li> </ul> </li> <li> <p>From the wally package manager.</p> <ul> <li>1: Copy the code on the \"Install\" section.</li> <li>2: Inside your <code>wally.toml</code> file, paste this code under the \"dependencies\" section.</li> <li>3: Run <code>wally install</code> through the command line.</li> </ul> </li> </ul>"},{"location":"tutorials/#testing","title":"Testing","text":"<p>To make sure if Class++ has been successfully installed or not, you can create a simple script to test.</p>"},{"location":"tutorials/#testing-from-roblox","title":"Testing from Roblox","text":"<ul> <li>1: Create a <code>Script</code> or a <code>LocalScript</code> instance, and parent it to <code>workspace</code> or <code>StarterPlayer &gt; StarterPlayerScripts</code>.</li> <li>2: Remove the <code>print(\"Hello World\")</code> line, and paste the following code in:</li> </ul> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\") -- If you've inserted it to somewhere else, you can change this line.\nlocal ClassPP = require(ReplicatedStorage.ClassPP)\nlocal class = ClassPP.class\n</code></pre> <ul> <li>3: Press \"Play\" or \"Run\". If everything is working properly and there are no errors, you're good to go!</li> </ul>"},{"location":"tutorials/#testing-from-source-code","title":"Testing from Source Code","text":"<p>If you're using the source code, you can <code>require()</code> Class++ in one of the following ways:</p> <pre><code>-- Rojo (Roblox Instance)\nlocal ClassPP = require(ReplicatedStorage.ClassPP)\n\n-- Vanilla Luau (Using Require By String)\nlocal ClassPP = require(\"../shared/ClassPP\")\n</code></pre>"},{"location":"tutorials/advanced/friendAccessSpecifier/","title":"Friend Access Specifier","text":"<p>Sometimes, you may wish to access the private members of a class without having to use a class method. Perhaps for a utility or a library function, you may wish to grant them access to the private members of your class. This is where the friend access specifier comes in. </p> <p>The friend access specifier allows all functions, and even classes, defined inside itself to access the private members of a class.</p> <p>Warning</p> <p>Members of this access specifier will not be replicated to objects, rather, these members are stored in the class itself.</p> <pre><code>local function getLicensePlate(object: any)\n    print(object.License_Plate)\nend\n\nlocal class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    },\n    Friend = {\n        getLicensePlate\n    }\n}\n\nlocal newCar = Car.new()\ngetLicensePlate(newCar)\n</code></pre> <p>In this example, we have a \"Car\" class that contains a private member called <code>License_Plate</code>, and a local function called <code>getLicensePlate</code>. By passing the reference to the <code>getLicensePlate</code> function inside the friend access specifier, this function is now able to access the private members of a class.</p> <p>Info</p> <p>Besides functions, friend access specifier can include other classes as well. Classes can be saved by using their variables, or their names. You can put a string inside the friend access specifier that contains a class's name, and it will still work!</p>"},{"location":"tutorials/advanced/functionOverloading/","title":"Function Overloading","text":"<p>Just like in other object oriented languages, Class++ supports function overloading.</p> <p>Function Overloading is a feature where multiple functions can share the same name, but they are different from each other with different amount of arguments.</p> <p>To do function overloading in Class++, you have to use the <code>class.overload(&lt;accessSpecifier&gt;, &lt;name&gt;, &lt;functionTable&gt;)</code> function.</p> <pre><code>local class = ClassPP.class\n\nlocal Test = class \"Test\" {\n    Public = {\n        ValueA = 0,\n        ValueB = 0\n    }\n}\n\nTest.overload(\"Public\", \"Set\", {\n    function(self, a, b)\n        print(a, b)\n        self.ValueA = a\n        self.ValueB = b\n    end,\n    function(self, a)\n        print(a)\n        self.ValueA = a\n    end,\n    function(self)\n        print(self.ValueA, self.ValueB)\n    end\n})\n\nlocal newTest = Test.new()\nnewTest:Set(1, 2) -- Prints \"1 2\"\nnewTest:Set(3) -- Prints \"3\"\nnewTest:Set() -- Prints \"3 2\"\n</code></pre> <p>In this example, to create an overloaded function, we used the <code>.overload()</code> function with the <code>Public</code> access specifier, and <code>Set</code> for the function name. Then we gave a table with multiple functions with different arguments that each do a different action. When we call the <code>:Set()</code> function through the object, depending on the amount of the given arguments, only the function that accepts the same amount of arguments will be ran.</p> <p>Warning</p> <p>Giving multiple functions that have the same amount of arguments will cause only one of these functions to be ran. Only create one function for a specific amount of arguments.</p>"},{"location":"tutorials/advanced/inheritance/","title":"Inheritance","text":"<p>Just like in other object oriented languages, Class++ allows you to inherit classes.  We group the inheritance concept into two categories: derived class (child), and the base class (parent). Inheritance implements an is-a relationship between classes.</p> <pre><code>local class = ClassPP.class\n\nlocal Vehicle = class \"Vehicle\" { -- Base Class\n    Public = {\n        Brand = \"Tesla\",\n        Model = \"S\",\n        License_Plate = \"BITE 1987\",\n        Year = 2012,\n        honk = function(self)\n            print(\"honk honk!\")\n        end\n    }\n}\n\nlocal Car = class \"Car\" (Vehicle, nil) { -- Derived Class\n    Public = {\n        License_Plate = \"A1B2C3\"\n    }\n}\n\nlocal newCar = Car.new()\nnewCar:honk()\nprint(newCar.Brand, newCar.Model, newCar.License_Plate, newCar.Year) -- Prints \"Tesla S A1B2C3 2012\"!\n</code></pre> <p>In this example, we have 2 classes: The \"Vehicle\" class (base), and the \"Car\" class (child).  We created the Car class by providing the <code>class</code> function a list of classes to inherit from (in this case, only the Vehicle class), and the <code>classData</code> table after.</p> <p>When you create a class using this method, you create a new derived class that inherits all of the members and member functions from the class(es) provided, so you don't need to re-declare them again. The members are overwritable in the derived class, like in the example above, you can modify the <code>License_Plate</code>'s default value to anything you wish. The same applies to other members.</p> <p>Question</p> <p>\"Why should I use Inheritence?\" It's very useful for code reusability: reusing members and functions of an existing class when you're creating a new class will save you a lot of time and effort, defining same members over and over again may cause spaghetti code and decrease code readability.</p>"},{"location":"tutorials/advanced/inheritance/#protected-access-specifier","title":"Protected Access Specifier","text":"<p>In Class++, private members can never be inherited by derived classes. But what if you wanted to make a member able to be inherited by other classes, while still preventing outside access to it? The protected access specifier allows you to achieve exactly this, the members stored in this access specifier can be inherited by derived classes, while still being inaccessible from the outside world.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Protected = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal BiggerCar = class \"BiggerCar\" (Car, nil) {\n    Public = {\n        Brand = \"Tesla\"\n    }\n}\n\nfunction BiggerCar.Public:printLicensePlate()\n    print(self.License_Plate) -- Will print \"XXXX\"!\nend\n\nlocal newCar = BiggerCar.new()\nnewCar:printLicensePlate()\n</code></pre> <p>In this example, we put the member <code>License_Plate</code> under the protected access specifier, and created a new class that inherits from the \"Car\" class. This derived class and its methods will now be able to access this member. </p> <p>Members in the protected access specifier are overwritable by members in other access specifiers. This means, when you define a member in the public or the private access specifier that has the same name as a member in the protected access specifier, this new member will overwrite the protected member, meaning the protected member will now be removed.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Protected = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal BiggerCar = class \"BiggerCar\" (Car, nil) {\n    Public = {\n        License_Plate = \"A1B2C3\"\n    }\n}\n\nfunction BiggerCar.Public:printLicensePlate()\n    print(self.License_Plate) -- Will print \"A1B2C3\"!\nend\n\nlocal newCar = BiggerCar.new()\nnewCar:printLicensePlate()\n</code></pre>"},{"location":"tutorials/advanced/inheritance/#super","title":"super","text":"<p>Let's say that you want to access a method in a base class from a derived class, how would you do it? Creating a new object from the base class and calling the method would be tedious, as it would take longer to write and would reduce performance and increase memory usage.</p> <p>Fortunately, for this, you can just call the default <code>super</code> method of an object, which allows you to call the method in a base class that has the same name of the method it's been called from.</p> <pre><code>local class = ClassPP.class\n\nlocal A = class \"A\" { \n    Public = {\n        getVariable = function(self)\n            return self.Variable_A\n        end\n    },\n    Protected = {\n        Variable_A = 1\n    }\n}\n\nlocal B = class \"B\" (A, nil) { \n    Public = {\n        Variable_B = 1,\n        getVariable = function(self)\n            return self:super()\n        end\n    }\n}\n\nlocal newObject = B.new()\nprint(newObject:getVariable()) -- 1\n</code></pre> <p>In this example, we created a new class called \"B\" that inherits from \"A\". In both classes, we have a method called <code>getVariable()</code>. In the base class, this method returns the value of the member <code>Variable_A</code>, and in the derived class, this method returns the value from the <code>getVariable()</code> method from the base class, by calling the <code>super()</code> method. </p> <p>Warning</p> <p><code>super</code> cannot be used within classes that have multi-inheritance. This is due to ambiguity that occurs with functions that have the same name in classes that have multi-inheritance. </p>"},{"location":"tutorials/advanced/inheritance/#multilevel-inheritance","title":"Multilevel-Inheritance","text":"<p>A class can also be derived from one class, which can be derived from another class:</p> <pre><code>local class = ClassPP.class\n\nlocal Person = class \"Person\" { -- Base Class\n    Public = {\n        Name = \"\",\n        Age = 0,\n        Gender = \"\",\n        Height = 0\n    }\n}\n\nlocal Child = class \"Child\" (Person, nil) { -- Derived Class\n    Public = {\n        Age = 9,\n        Energetic = true\n    }\n}\n\nlocal Student = class \"Student\" (Child, nil) { -- Derived Class from a Derived Class\n    Public = {\n        SchoolId = 0,\n        Grade = 0,\n        Behaviour = \"Good\"\n    }\n}\n\nlocal newStudent = Student.new()\nprint(newStudent.Name, newStudent.Age, newStudent.Gender, newStudent.Height, newStudent.Age, newStudent.Energetic, newStudent.SchoolId, newStudent.Grade, newStudent.Behaviour)\n-- Prints \" 9  0 9 true 0 0 Good\"! (Spaces represent empty strings)\n</code></pre>"},{"location":"tutorials/advanced/inheritance/#multi-inheritance","title":"Multi-Inheritance","text":"<p>Warning</p> <p>Multi-Inheritance is not Multilevel-Inheritance. While their names may be similar, they represent different concepts.</p> <p>A class can also be derived from multiple classes:</p> <pre><code>local class = ClassPP.class\n\nlocal A = class \"A\" { \n    Public = {\n        Variable_A = 1\n    }\n}\n\nlocal B = class \"B\" { \n    Public = {\n        Variable_B = 1\n    }\n}\n\nlocal C = class \"C\" (A, B) { -- Derived Class\n    Public = {\n        Variable_C = 1\n    }\n}\n\nlocal newObject = C.new() -- {Variable_A: number, Variable_B: number, Variable_C: number}\n</code></pre>"},{"location":"tutorials/advanced/inheritance/#the-diamond-problem","title":"The Diamond Problem","text":"<p>The Diamond Problem is an ambiguity that arises when two classes, let's say \"B\" and \"C\", that inherits from a class called \"A\", and another class \"D\" that inherits from both \"B\" and \"C\". If there is a method in \"A\" that \"B\" and \"C\" have overridden, and \"D\" does not override it, then which version of the method does \"D\" inherit from: that of \"B\", or that of \"C\"?</p> <pre><code>local class = ClassPP.class\n\nlocal A = class \"A\" { \n    Public = {\n        method = function(self)\n            print(\"Method from A\")\n        end\n    }\n}\n\nlocal B = class \"B\" (A, nil) { \n    Public = {\n        method = function(self)\n            print(\"Method from B\")\n        end\n    }\n}\n\nlocal C = class \"C\" (A, nil) { -- Derived Class\n    Public = {\n        method = function(self)\n            print(\"Method from C\")\n        end\n    }\n}\n\nlocal D = class \"D\" (B, C) { -- Derived Class\n    Public = {\n        -- Which method will D have, B's or C's?\n    }\n}\n</code></pre>"},{"location":"tutorials/advanced/inheritance/#how-class-solves-the-diamond-problem","title":"How Class++ solves the Diamond Problem","text":"<p>In Class++, the class inheritation system does not work by referencing the parent classes, but rather for the sake of performance, it combines the given classes into a new one. The combination is done in an order, from the first given class argument to the last. Certain Access Specifiers such as Protected can change how this system behaves.</p> <p>To create class \"D\", Class++ takes the class arguments one by one in an order, from left to right, and combines their <code>classData</code> and the given <code>classData</code> table into a new class. So due to this order, class \"B\"'s members and methods will automatically be overwritten by class \"C\"'s, therefore the method that will exist on class \"D\", will be the method of class \"C\"'s.</p> <p>This is similar to the Python's MRO (Method Resolution Order).</p> <pre><code>local class = ClassPP.class\n\nlocal A = class \"A\" { \n    Public = {\n        method = function(self)\n            print(\"Method from A\")\n        end\n    }\n}\n\nlocal B = class \"B\" (A, nil) { \n    Public = {\n        method = function(self)\n            print(\"Method from B\")\n        end\n    }\n}\n\nlocal C = class \"C\" (A, nil) { -- Derived Class\n    Public = {\n        method = function(self)\n            print(\"Method from C\")\n        end\n    }\n}\n\nlocal D = class \"D\" (B, C) {} -- Derived Class\n\nlocal newObject = D.new()\nnewObject:method() -- Prints \"Method from C\"!\n</code></pre>"},{"location":"tutorials/advanced/nonAccessSpecifiers/","title":"Non-Access Specifiers","text":"<p>Unlike access specifiers, non-access specifiers do not modify the access control of a member, but rather provide other functionality for classes.</p>"},{"location":"tutorials/advanced/nonAccessSpecifiers/#final","title":"Final","text":"<p>Using this non-access specifier will make the given class final, meaning this class now cannot be inherited by other classes.</p> <pre><code>local class, final = ClassPP.class, ClassPP.final\n\nlocal Car = final { class \"Car\" {\n    Public = {\n        Brand = \"Ford\",\n    }\n}}\n\nlocal BiggerCar = class \"BiggerCar\" (Car, nil) { -- This will error!\n    Public = {\n        Brand = \"Tesla\"\n    }\n}\n</code></pre>"},{"location":"tutorials/advanced/nonAccessSpecifiers/#abstract","title":"Abstract","text":"<p>Using this non-access specifier will make the given class an abstract class, meaning this class now cannot be used to create objects. To access an abstract class's members, you need to create a class that inherits from this abstract class.</p> <pre><code>local class, abstract = ClassPP.class, ClassPP.abstract\n\nlocal BaseCar = abstract { class \"BaseCar\" {\n    Public = {\n        Brand = \"\",\n        Model = \"\",\n        Year = 0,\n        honk = function(self)\n            print(\"honk honk!\")\n        end\n    }\n}}\n\nlocal Car = class \"Car\" (BaseCar, nil) {\n    Public = {\n        Brand = \"Ford\",\n        Model = \"Mustang\",\n        Year = 2023\n    }\n}\n\nlocal newBaseCarObj = BaseCar.new() -- This will error!\nlocal newCarObj = Car.new() -- This will work fine!\nnewCarObj:honk()\n</code></pre> <p>Warning</p> <p>Creating Private members in an abstract class will cause these members to never be accessible, since Private members of a class will never be inherited to another class.</p> <pre><code>local class, abstract = ClassPP.class, ClassPP.abstract\n\nlocal BaseCar = abstract { class \"BaseCar\" {\n    Public = {\n        Brand = \"\",\n        Model = \"\",\n        Year = 0,\n        honk = function(self)\n            print(\"honk honk!\")\n        end\n    },\n    Private = {\n        Secret = \"\" -- This property will never be accessible!\n    }\n}}\n</code></pre> <p>Warning</p> <p>You cannot make a class both abstract and final, as they have opposite meanings. An abstract class must be subclassed, whereas a final class cannot be subclassed. Attempting to form an illegal combination between final and abstract methods will cause an error.</p>"},{"location":"tutorials/advanced/operatorOverloading/","title":"Operator Overloading","text":"<p>Suppose we have two objects that belong to a custom Vector class, how would we allow the addition of those two objects? Using a normal class method would suffice, but it would require you to call the same method over and over again every single time you want to add them together.</p> <p>To solve this issue, just like in other object oriented languages, we can change the way operators work for our classes. This is known as operator overloading.</p> <pre><code>local class = ClassPP.class\n\nlocal Vector = class \"Vector3\" {\n    constructor = function(self, x: number, y: number, z: number)\n        if typeof(x) ~= \"number\" or typeof(y) ~= \"number\" or typeof(z) ~= \"number\" then self.coordinates = {0, 0, 0} return end\n        self.coordinates = {x, y, z}\n    end,\n    Public = {\n        coordinates = {0, 0, 0},\n    },\n}\n\nfunction Vector.Public:operator_add(otherVector)\n    assert(#self.coordinates == #otherVector.coordinates)\n\n    local coordinates = {}\n\n    for i = 1, #self.coordinates do\n        coordinates[i] = self.coordinates[i] + otherVector.coordinates[i]\n    end\n\n    return Vector.new(coordinates[1], coordinates[2], coordinates[3])\nend\n\nfunction Vector.Public:__tostring()\n    return \"(\" .. table.concat(self.coordinates, \", \") .. \")\"\nend\n\nlocal vector1 = Vector.new(4, 5, 2)\nlocal vector2 = Vector.new(1, 2, 3)\n\nprint(vector1 + vector2) -- Prints \"(5, 7, 5)\"\n</code></pre> <p>In this example, we have created a custom Vector3 class that has a special function called <code>operator_add</code>, this special function is one of the special functions in Class++ that allows you to overload a specific operator. Here, we overloaded the operator <code>+</code> with our custom function that allows us to add two Vectors together.</p>"},{"location":"tutorials/advanced/operatorOverloading/#overloadable-operators","title":"Overloadable Operators","text":"Method Description <code>operator_add(self, obj)</code> Function for overloading the + operator. <code>operator_sub(self, obj)</code> Function for overloading the - operator. <code>operator_mul(self, obj)</code> Function for overloading the * operator. <code>operator_div(self, obj)</code> Function for overloading the / operator. <code>operator_idiv(self, obj)</code> Function for overloading the // operator. <code>operator_mod(self, obj)</code> Function for overloading the % operator. <code>operator_pow(self, obj)</code> Function for overloading the ^ operator. <code>operator_unm(self)</code> Function for overloading the unary \u2013 operator. <code>operator_eq(self, obj)</code> Function for overloading the == operator.\u00b9 <code>__tostring()</code> Fired when tostring is called on the object. <p>Info</p> <p>\u00b9: This function will only run when == operator is used with the same base type (table, userdata, etc.). It will not work with different types, such as an object with a table, or another type.</p> <p>Warning</p> <p>Trying to directly call the operator functions will result in an error. They must be called with their operators.</p>"},{"location":"tutorials/advanced/staticMembers/","title":"Static Members","text":"<p>Static members are members of the class that will exist regardless of whether or not any objects of the class are created. Once a static member has been created, they cannot be destroyed or modified in any way. Static members are also global, so all class objects have access to them, and their property will be the same across all of the objects.</p> <p>To create a static member in Class++, you have to use the <code>class.static(&lt;accessSpecifier&gt;, &lt;name&gt;, &lt;property&gt;)</code> function.</p> <pre><code>local class = ClassPP.class\n\nlocal Test = class \"Test\" {\n    Public = {\n        TestValue = 0\n    }\n}\n\nTest.static(\"Public\", \"StaticTestValue\", function(firstArgument)\n    print(firstArgument) -- This will not point to any object, instead it will print whatever it is called with! In this case, it will print \"Hi!\".\nend)\n\nlocal newTest = Test.new()\nnewTest:StaticTestValue() -- This will error!\n\nTest.StaticTestValue(\"Hi!\") -- This will work fine!\n</code></pre> <p>You can also give properties that aren't functions. To retrieve those properties, you can do <code>class.&lt;memberName&gt;.property</code> or <code>class.&lt;memberName&gt;.p</code> for short.</p> <pre><code>local class = ClassPP.class\n\nlocal Test = class \"Test\" {\n    Public = {\n        TestValue = 0\n    }\n}\n\nTest.static(\"Public\", \"StaticTestValue\", 1)\n\nprint(Test.StaticTestValue.property) -- Prints \"1\"!\nprint(Test.StaticTestValue.p) -- Also prints \"1\"!\n</code></pre>"},{"location":"tutorials/advanced/types/","title":"Types","text":""},{"location":"tutorials/advanced/types/#intellisense","title":"Intellisense","text":"<p>Class++ in 2.0, has been rewritten from ground up to support the new type-solver and its capabilities.  This allows Class++ to be more intelligent with the <code>class</code> and <code>object</code> types, finally allowing the intellisense to be far better than what it used to be. </p> <pre><code>local Person = class \"Person\" {\n    Public = {\n        Age = 0,\n        Name = \"\",\n        Personality = \"\",\n        Likes = {},\n        Dislikes = {},\n        Job = \"\",\n        getSecrets = function(self)\n            return self.Secrets\n        end,\n    },\n    Private = {\n        Secrets = {}\n    }\n}\n\nlocal newPerson = Person.new() -- Now has intellisense for members in all access specifiers, and obtains the correct types for every member!\n</code></pre> <p>This also applies to classes, where before you tried to create an inherited class, the returned class type would not be correct, and new objects would also not have the correct type. For example, some members of an inherited class would be missing from auto-complete.</p> <p>Now, this has also been fixed:</p> <pre><code>local class = ClassPP.class\n\nlocal A = class \"A\" { \n    Public = {\n        Variable_A = 1\n    }\n}\n\nlocal B = class \"B\" { \n    Public = {\n        Variable_B = 1\n    }\n}\n\nlocal C = class \"C\" (A, B) { -- Derived Class\n    Public = {\n        Variable_C = 1\n    }\n}\n\nlocal newObject = C.new() -- {Variable_A: number, Variable_B: number, Variable_C: number}\n</code></pre> <p>Though, as much as this update brings in an intellisense much better than before, it is still limited. Like in the previous versions of Class++, to support all the features of types in Luau, you have to create a custom type and assign it to the created objects.</p> <p>In the tutorial below, you will learn how to create a basic <code>Person</code> type and assign it to the created object, to enable the support.</p>"},{"location":"tutorials/advanced/types/#creating-a-basic-custom-class-type","title":"Creating a Basic Custom Class Type","text":"<pre><code>local class = ClassPP.class\n\ntype Person = {\n    Age: number,\n    Name: string,\n    Personality: string,\n    Job: string,\n    Secrets: {string},\n    Likes: {string},\n    Dislikes: {string},\n    getSecrets: (self: Person) -&gt; {string}\n}\n\nlocal Person = class \"Person\" {\n    Public = {\n        Age = 0,\n        Name = \"\",\n        Personality = \"\",\n        Likes = {},\n        Dislikes = {},\n        Job = \"\",\n        getSecrets = function(self: Person)\n            return self.Secrets\n        end,\n    },\n    Private = {\n        Secrets = {}\n    }\n}\n\nlocal newPerson: Person = Person.new()\n-- This object now fully supports all type features of Luau!\n</code></pre> <p>In the example above, we created a custom type called <code>Person</code> for the Person class, and inserted the types of all the members inside it, and declared the new created object as of the Person type. This now allows us to use all the features of Luau types.</p> <p>Info</p> <p>Since class objects belong to the base type <code>userdata</code>, you can type cast them to either your custom types, or any other existing type you wish.</p>"},{"location":"tutorials/advanced/types/#typechecking-for-classes-and-class-objects","title":"Typechecking for Classes and Class Objects","text":"<p>Class++ also comes with its own <code>Type</code> API that allows you to get the types of <code>class</code>es and <code>object</code>s.</p> <pre><code>local class = ClassPP.class\nlocal type, typeof = ClassPP.Type.type, ClassPP.Type.typeof\n\ntype Person = {\n    Age: number,\n    Name: string,\n    Personality: string,\n    Job: string,\n    Secrets: {string},\n    Likes: {string},\n    Dislikes: {string},\n    getSecrets: (self: Person) -&gt; {string}\n}\n\nlocal Person = class \"Person\" {\n    Public = {\n        Age = 0,\n        Name = \"\",\n        Personality = \"\",\n        Likes = {},\n        Dislikes = {},\n        Job = \"\",\n        getSecrets = function(self: Person)\n            return self.Secrets\n        end,\n    },\n    Private = {\n        Secrets = {}\n    }\n}\n\nlocal newPerson: Person = Person.new()\nprint(type(Person), \",\", type(newPerson)) -- Prints \"Class, Object\"!\nprint(typeof(Person), \",\", typeof(newPerson)) -- Prints \"Person, Person\"!\n</code></pre>"},{"location":"tutorials/advanced/types/#typetype","title":"Type.type","text":"<p><code>Type.type</code> will return the true type of the given object. It behaves the same as the built-in luau <code>type</code> function, but with additional support for <code>class</code>es and <code>object</code>s. For example, if the provided object is a <code>class</code>, it will return a string called \"Class\". This is due to the <code>class</code> object belonging to the base <code>Class</code> type.</p> <p>The same applies to <code>object</code>s, where if the provided object is an <code>object</code>, it will return a string called \"Object\". This is due to the <code>object</code> belonging to the base <code>Object</code> type.</p>"},{"location":"tutorials/advanced/types/#typetypeof","title":"Type.typeof","text":"<p><code>Type.typeof</code> will return the type of the given object. Like <code>Type.type</code>, it behaves the same as the built-in Roblox <code>typeof</code> function, but with additional support for <code>class</code>es and <code>object</code>s. For example, if the provided object is a <code>class</code>, it will return a string containing the name of the <code>class</code>. This is due to <code>class</code>es are also being types on their own. They can also be represented as types.</p> <p>For <code>object</code>s, this function will return the type of the <code>class</code> they belong to. For example, using this function with an <code>object</code> created from a \"Person\" <code>class</code>, will return \"Person\" as its type.</p> <p>Info</p> <p><code>Type.type</code> and <code>Type.typeof</code> functions can be used to replace the built-in <code>type</code> and <code>typeof</code> functions, as they behave the same with other provided objects. For example, using <code>Type.typeof</code> and <code>typeof</code> with a <code>string</code> will both return \"string\".</p> <p>Warning</p> <p>Using the <code>class.Name</code> property may create bugs in certain places as the Type API makes sure the given object is an actual <code>class</code> object before returning its type. It's recommended that you use the Type API instead of the <code>.Name</code> property.</p>"},{"location":"tutorials/basics/accessSpecifiers/","title":"Access Specifiers","text":"<p>In the previous page, you may have noticed that we have defined our members inside a specific table, called \"Public\", inside the <code>classData</code> table. This table represents an \"Access Specifier\". It allows you to modify the access control of a specific member, essentially allowing you to control where the member can be accessed from. This concept comes from certain object oriented languages such as C++, allowing you to apply many OOP concepts effectively in Luau.</p> <p>There are currently 4 access specifiers in Class++: <code>Public</code>, <code>Private</code>, <code>Protected</code>, and <code>Friend</code>. (<code>Protected</code> and <code>Friend</code> are mentioned in later pages.)</p>"},{"location":"tutorials/basics/accessSpecifiers/#public-access-specifier","title":"Public Access Specifier","text":"<p>The public access specifier allows the member to be accessed from anywhere. Whether it be from a function inside the class or from the main thread, the member is accessible and can be modified.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    }\n}\n\nlocal newCar = Car.new()\nnewCar.Brand = \"Tesla\"\n</code></pre> <p>In this example, we created a new class with a public member <code>Brand</code> that has the default value of <code>Lamborghini</code>. Then we created a new object from this class and modified the <code>Brand</code> member of this object. Now the value is set to <code>Tesla</code>.</p>"},{"location":"tutorials/basics/accessSpecifiers/#private-access-specifier","title":"Private Access Specifier","text":"<p>The private access specifier allows the member to only be accessed from class functions, essentially locking the member from the outside world.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal newCar = Car.new()\nnewCar.License_Plate = \"YYYY\" -- This will error!\n</code></pre> <p>In this example, we updated the previous class with a private member named <code>License_Plate</code>, this member is private and can only be accessed from the class functions, so trying to access or modify it outside of the class functions will cause an error.</p> <p>Warning</p> <p>A member (property/attribute) can be declared only once. This means a member can only be defined under one access specifier. Attempting to declare a member in multiple access specifiers will cause an error.</p>"},{"location":"tutorials/basics/classConstructors/","title":"Class Constructors and Destructors","text":"<p>Up until this point, we have only updated an object's members from either on the main thread, or inside of a class method. This is fine when it comes to public members, as they can be accessed anywhere. However, when it comes to other member types, such as private members, this can become tedious, as you have to call a class method every single time if you want to update them after object creation.</p> <p>Fortunately, to solve these issues, there are 2 special functions that you can define in every class, called: <code>constructor</code> and <code>destructor</code>.</p>"},{"location":"tutorials/basics/classConstructors/#class-constructors","title":"Class Constructors","text":"<p>A constructor is a special function that gets called when an object is created. To create a constructor, you have to specifically define a function called <code>constructor</code> outside of the access specifiers. Constructors can be really useful for setting initial values for certain members.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    constructor = function(self)\n        self.License_Plate = \"YYYY\"\n    end,\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal newCar = Car.new()\n</code></pre> <p>When <code>Car.new()</code> is called, it will automatically call the constructor function.</p>"},{"location":"tutorials/basics/classConstructors/#constructor-parameters","title":"Constructor Parameters","text":"<p>Constructors, like regular class methods, can take parameters. Unlike class methods however, a constructor will always have <code>self</code> (the object) as the first parameter, regardless of how you call the <code>class.new()</code> function.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    constructor = function(self, brand, model, licensePlate)\n        self.License_Plate = licensePlate\n        self.Brand = brand\n        self.Model = model\n    end,\n    Public = {\n        Brand = \"\",\n        Model = \"\",\n        License_Plate = \"\"\n    },\n}\n\nlocal newCar = Car.new(\"ABCD\", \"Ford\", \"Mustang\")\nprint(newCar.Brand, newCar.Model, newCar.License_Plate) -- Prints \"ABCD, Ford, Mustang\"!\n</code></pre>"},{"location":"tutorials/basics/classConstructors/#class-destructors","title":"Class Destructors","text":"<p>A destructor is a special function that runs when you call the default <code>:Destroy()</code> method on an object. To create a destructor, you have to specifically define a function called <code>destructor</code> outside of the access specifiers.</p> <p>Info</p> <p><code>object:Destroy()</code> is a reserved special method that all objects have. Due to this, you cannot define any member or a method that is called \"Destroy\".</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    constructor = function(self, brand, model, licensePlate)\n        self.License_Plate = licensePlate\n        self.Brand = brand\n        self.Model = model\n    end,\n    destructor = function(self)\n        self.License_Plate = \"\"\n        self.Brand = \"\"\n        self.Model = \"\"\n    end,\n    Public = {\n        Brand = \"\",\n        Model = \"\",\n        License_Plate = \"\"\n    },\n}\n\nlocal newCar = Car.new(\"ABCD\", \"Ford\", \"Mustang\")\nprint(newCar.Brand, newCar.Model, newCar.License_Plate)\n\nnewCar:Destroy() -- The class object will now be destroyed\nnewCar = nil\n</code></pre> <p>Unlike <code>constructor</code>, the <code>destructor</code> function does not take any additional parameters, and the only parameter will be the <code>self</code> pointing to the object. After the <code>destructor</code> is called, all members inside the object will be set to <code>nil</code>, and the object will be locked, preventing any further access. At this stage, the object should be treated as completely empty and gone, so you should remove all references to the object to prevent memory leaks.</p> <p>Instances, threads and connections inside an object will automatically be cleared and destroyed during the clearing process as well.</p>"},{"location":"tutorials/basics/classConstructors/#automatic-object-destruction","title":"Automatic Object Destruction","text":"<p>Unlike any other class and object creation system in Luau, Class++ comes with a built-in automatic object destruction system. This system automatically destroys an object when it deems there are no longer any references made to the object itself. </p> <p>If this system detects that there are no longer any references made to an object, it will first call the <code>destructor</code> function for the object, if defined. And next, it will apply the standard destruction protocol for the object, clearing any data left inside.</p> <p>This system reduces potential memory leaks that may happen due to non-destroyed objects that still have data stored in memory. However, if you wish to apply full manual memory management instead, you can set the <code>autoObjectDestruction</code> property of the main library to <code>false</code>.</p> <p>Info</p> <p>Constructor and Destructor functions can also be written in the outside class definition syntax.</p>"},{"location":"tutorials/basics/classCreation/","title":"Classes and Objects","text":"<p>A class is an user defined data structure. It's made out of members and member functions(methods). Those members and member functions can then be accessed by creating an object from that class. Think of a class as a blueprint for an object.</p>"},{"location":"tutorials/basics/classCreation/#creating-a-class","title":"Creating a Class","text":"<p>To create a new class with Class++, you use the <code>class()</code> function of the main library. The first argument must be a string that defines the name of the class, and the next argument must be the <code>classData</code>, a table that contains all the access specifiers and the member data.</p> <pre><code>local class = ClassPP.class\n\nlocal person = class \"Person\" {\n    Public = {\n        Name = \"\",\n        Age = 0\n    }\n}\n</code></pre> <p>In the above example, we created a new class with the name <code>Person</code>, and under the public access specifier, we created two members named: <code>Name</code> and <code>Age</code> with certain default values assigned to them. These members and their default values will be transferred to every object created from this class.</p>"},{"location":"tutorials/basics/classCreation/#creating-an-object","title":"Creating an Object","text":"<p>Now that we have a class, we can create an object from it. In Class++, to create an object, you use the <code>.new()</code> method a class. When called, this method returns an object created from this class, and like it's been mentioned above, it will contain all of the members and their default values from the class it's been created from.</p> <pre><code>local class = ClassPP.class\n\nlocal person = class \"Person\" {\n    Public = {\n        Name = \"\",\n        Age = 0\n    }\n}\n\nlocal newPerson = person.new()\nprint(newPerson.Age) -- Prints \"0\"!\n</code></pre>"},{"location":"tutorials/basics/classCreation/#updating-an-object","title":"Updating an Object","text":"<p>Of course, by indexing the object with a specific member, you can update that specific member's associated value. There are some restrictions that can be applied to this however, which you will learn in later pages.</p> <pre><code>local class = ClassPP.class\n\nlocal person = class \"Person\" {\n    Public = {\n        Name = \"\",\n        Age = 0\n    }\n}\n\nlocal newPerson = person.new()\nnewPerson.Age = 21\n\nprint(newPerson.Age) -- Prints \"21\"!\n</code></pre> <p>Warning</p> <p>In Class++, members and their values must be defined through either the <code>class()</code> function, or by simply indexing a created class and assigning a new member to an access specifier through it. Trying to define a new member through the object will cause an error.</p> <pre><code>local class = ClassPP.class\n\nlocal person = class \"Person\" {\n    Public = {\n        Name = \"\",\n        Age = 0\n    }\n}\n\nlocal newPerson = person.new()\nnewPerson.Personality = \"Cheerful\" -- This will error! This class has no member named \"Personality\".\n</code></pre>"},{"location":"tutorials/basics/classMethods/","title":"Class Functions","text":"<p>So far, we have only created simple members that hold simple values, what about functions?</p> <p>Just like in other object oriented languages, there are two ways to define a function (method) inside a class:</p> <ul> <li>Inside class definition</li> <li>Outside class definition</li> </ul> <p>Info</p> <p>Class Functions are also called Class Methods, and we will use this term from now on in later pages of the tutorials.</p>"},{"location":"tutorials/basics/classMethods/#inside-class-definition","title":"Inside Class Definition","text":"<pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n        getLicensePlate = function(self)\n            print(self.License_Plate)\n        end\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n</code></pre> <p>In this example, we have defined a new function inside the public access specifier called <code>getLicensePlate</code>, this function when called will print the license plate of our object. </p> <p>Now, let's create an object from this class:</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n        getLicensePlate = function(self)\n            print(self.License_Plate)\n        end\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal newCar = Car.new()\nnewCar:getLicensePlate()\n</code></pre> <p>You might have noticed that we've called the <code>getLicensePlate</code> function with the <code>:</code> (colon) operator. This is a syntax sugar that we use to pass the object itself as the first argument to a function. Calling a function with the <code>:</code> operator is equivalent to calling it like <code>object.method(object)</code>, but it makes our job easier because we don't have to manually pass the object every single time when calling the function.</p> <p>Due to this, the first argument of a function will always be what we call <code>self</code>, that is a pointer to the object. We use it to access the object's properties inside the function.</p>"},{"location":"tutorials/basics/classMethods/#functions-with-multiple-parameters","title":"Functions with multiple parameters","text":"<pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n        setLicensePlate = function(self, newPlate)\n            self.License_Plate = newPlate \n        end,\n        getLicensePlate = function(self)\n            return self.License_Plate\n        end\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal newCar = Car.new()\nnewCar:setLicensePlate(\"A1B2C3\") -- Calling the function with an argument\nprint(newCar:getLicensePlate()) -- Prints \"A1B2C3\"!\n</code></pre> <p>In the example above, we added a new function called <code>setLicensePlate</code> that updates the private member <code>License_Plate</code> with the provided <code>newPlate</code> parameter. We've also updated the <code>getLicensePlate</code> function to return the private member <code>License_Plate</code>, which we then use to print the now updated value of the member. Make sure to remember that <code>self</code> should always be the first parameter, and all the other parameters should come after it.</p>"},{"location":"tutorials/basics/classMethods/#outside-class-definition","title":"Outside Class Definition","text":"<p>You're not limited to always defining functions inside of the <code>classData</code> itself. You can also define it outside of the <code>classData</code>, by using the method shown below.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nfunction Car.Public:getLicensePlate(number) -- You should always define a function through the Class.AccessSpecifier:FunctionName syntax.\n    print(self.License_Plate, number) -- Prints \"XXXX 1\"!\nend\n\nlocal newCar = Car.new()\nnewCar:getLicensePlate(1)\n</code></pre> <p>In this example, we defined a function outside of the class by specifying the class name, then the access specifier, followed by the <code>:</code> operator and the name of the function.</p>"},{"location":"tutorials/basics/classMethods/#typechecking","title":"Typechecking","text":"<p>Unlike any other object oriented language such as C++, Class++ does not require you to define class functions inside the <code>classData</code> first to use the outside class definition method. However, it comes with certain disadvantages.</p> <p>Unfortunately, defining class functions this way alone will not give you any intellisense when you're calling the function through the object. This is due to the limitations of the Luau's typechecking system. So, to get around this, we define the class function first inside the <code>classData</code> with only its parameter types, and then using the outside class definition method, we define the actual body of the function outside of the <code>classData</code>.</p> <pre><code>local ClassPP = require('./ClassPP')\nlocal class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n        getLicensePlate = function(number) end\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nfunction Car.Public:getLicensePlate(number)\n    print(self.License_Plate, number) -- Still prints \"XXXX 1\"!\nend\n\nlocal newCar = Car.new()\nnewCar:getLicensePlate(1)\n</code></pre> <p>Recommended</p> <p>Outside Class Definition method with the syntax above is recommended as it allows for a better formatting style.</p>"},{"location":"tutorials/best-practices/composition/","title":"Composition","text":"<p>Composition is another fundemental concept in OOP that combines objects or data types into more complex ones. This implements a has-a relationship between objects, rather than is-a from Inheritance.</p> <p>For example, let's imagine a coffee machine. This coffee machine has a grinder, a brewer, and many other components, but the coffee machine itself is not one of them.</p> <p><pre><code>local GroundCoffee = class \"GroundCoffee\" {}\nlocal Coffee = class \"Coffee\" {}\n\nlocal Grinder = class \"Grinder\" {\n    Public = {\n        grind = function(self)\n            -- Grinds the coffee and returns a new GroundCoffee\n            return GroundCoffee.new()\n        end,\n    }\n}\n\nlocal BrewingUnit = class \"BrewingUnit\" {\n    Public = {\n        brew = function(self, groundCoffee)\n            -- Brew the groundCoffee and return a new Coffee.\n            return Coffee.new()\n        end,\n    }\n}\n\nlocal CoffeeMachine = class \"CoffeeMachine\" {\n    constructor = function(self)\n        self.Grinder = Grinder.new()\n        self.BrewingUnit = BrewingUnit.new()\n    end,\n    Public = {\n        brewCoffee = function(self)\n            -- Brew the coffee using the grinder and the brewing unit of the object, and return it.\n        end,    \n    },\n    Private = {\n        Grinder = false,\n        BrewingUnit = false\n        -- Add other members to create a full coffee machine\n    }\n}\n</code></pre> In the example above, we have <code>GroundCoffee</code> and <code>Coffee</code> classes which are used within the <code>Grinder</code> and <code>BrewingUnit</code> classes, and the <code>CoffeeMachine</code> class that uses them. As you can see in the example, <code>CoffeeMachine</code> only exposes a <code>brewCoffee</code> method, that brews a <code>Coffee</code> and returns it. (Implementation details are skipped for the sake of clarity.)</p> <p>Like we have discussed in the Encapsulation page, by restricting access through only exposing a method to brew a coffee, we allow for data integrity, so we can be sure that <code>CoffeeMachine</code>'s <code>Grinder</code> and <code>BrewingUnit</code> objects will not change, and they cannot be accessed directly.</p> <p>Maintainability is also increased, as if the implementation of the <code>Grinder</code>'s <code>grind</code> method ever changes, <code>CoffeeMachine</code> will not be affected. The same can be said for <code>BrewingUnit</code> as well.</p>"},{"location":"tutorials/best-practices/composition/#composition-over-inheritance","title":"Composition Over Inheritance","text":"<p>Like we have mentioned in the Inheritance page, inheritance is a powerful way to achieve code reuse, but not always it is the best tool for the job. </p> <p>Inheritance may sometimes violate encapsulation. A derived class depends on the implementation details of its base class, so if the base class gets a change in its implementation, the derived class may break, even though its code hasn't been touched. Due to this, the derived class must also be updated alongside the base class, to ensure it works correctly.</p> <pre><code>local User = class \"User\" {\n    Public = {\n        login = function(self)\n            print(\"User logged in.\")\n        end\n    }\n}\n\nlocal Admin = class \"Admin\" (User, nil) {\n    Public = {\n        manageUsers = function(self) \n            print(\"Admin managing users.\")\n        end\n    }\n}\n\nlocal Editor = class \"Editor\" (User, nil) {\n    Public = {\n        editContent = function(self) \n            print(\"Editor editing content.\")\n        end\n    }\n}\n\nlocal Viewer = class \"Viewer\" (User, nil) {\n    Public = {\n        viewContent = function(self) \n            print(\"Viewer viewing content.\")\n        end\n    }\n}\n</code></pre> <p>In the example above, we have created a user hierarchy, where different types of users have different methods.  The problems with this system, however are:</p> <ul> <li>If we want to create a new role, or a new ability, we need to create a new class.</li> <li>If certain roles share the same functions, it might even decrease code reusability.</li> <li>If we want to create a user with multiple roles, such as an <code>Admin</code> whos also an <code>Editor</code>, the system becomes even more complicated.</li> </ul> <p>However, if we use composition over inheritance:</p> <pre><code>local Permission = class \"Permission\" {\n    Public = {\n        execute = function(self)\n            -- Execute the permission, can be overwritten.\n        end\n    }\n}\n\nlocal ManageUsers = class \"ManageUsersPermission\" (Permission, nil) {\n    Public = {\n        execute = function(self)\n            print(\"Managing users.\")\n        end\n    }\n}\n\nlocal EditContent = class \"EditContentPermission\" (Permission, nil) {\n    Public = {\n        execute = function(self)\n            print(\"Editing content.\")\n        end\n    }\n}\n\nlocal ViewContent = class \"ViewContentPermission\" (Permission, nil) {\n    Public = {\n        execute = function(self)\n            print(\"Viewing content.\")\n        end\n    }\n}\n\nlocal User = class \"User\" {\n    constructor = function(self, username) \n        self.Username = username\n    end\n    Public = {\n        addPermission = function(self, permission) \n            table.insert(self.Permissions, permission)\n        end,\n        login = function(self) \n            print(self.Username + \" logged in.\")\n        end,\n        executePermissions = function(self)\n            for _, permission in self.Permissions do\n                permission:execute()\n            end\n        end \n    },\n    Private = {\n        Username = \"\",\n        Permissions = {}\n    }\n}\n</code></pre> <p>In the example above, instead of mainly using inheritance, we used composition. In other words, instead of extending the users to create new classes, we extended permissions, that each can have different abilities and methods. This allowed us to create a very flexible <code>User</code> class that can have multiple permissions.</p>"},{"location":"tutorials/best-practices/composition/#tips","title":"Tips","text":"<p>Like you've seen in the examples above, composition over inheritance generally yields better results. However, this does not mean that inheritance holds no place in OOP, as in the above example when we created our permission classes, we still used inheritance.</p> <p>This phrase from \"Effective Java\" summarizes where you should use composition and inheritance very well: \"...a class B should extend a class A only if an \u201cis-a\u201d relationship exists between the two classes. If you are tempted to have a class B extend a class A, ask yourself the question: Is every B really an A? If you cannot truthfully answer yes to this question, B should not extend A. If the answer is no, it is often the case that B should contain a private instance of A and expose a different API: A is not an essential part of B, merely a detail of its implementation.\"</p>"},{"location":"tutorials/best-practices/encapsulation/","title":"Encapsulation","text":"<p>Encapsulation is a fundamental concept in OOP that combines data (properties) and methods (class functions) that work with that data into a single unit known as a class. This protective layer around the data allows it to maintain its integrity and prevents unauthorized access.</p> <p>For example, imagine a coffee machine. A coffee machine has a grinder, brewer, and many other internal components that allows it to function. But you don't need to know how it works, you only need to know which buttons to press to get your coffee. This is similar to how it works in OOP.</p>"},{"location":"tutorials/best-practices/encapsulation/#why-encapsulation","title":"Why Encapsulation?","text":"<ul> <li>Data Protection: By making the data private, you hide it from the outside world. Therefore, you protect it from accidental or intentional modifications from outside the class, ensuring its integrity. It also protects sensitive information.</li> <li>Data Validation: It allows you to ensure that the given data to the class is valid, and thus allowing for a safer system.</li> <li>Increased Maintainability: By controlling the access, any internal implementation changes are less likely to effect other external parts of the program.</li> <li>Increased Flexibility: It also allows for a cleaner interface, and due to the internal parts being private, the interface can be reused effectively. </li> </ul>"},{"location":"tutorials/best-practices/encapsulation/#implementation","title":"Implementation","text":"<pre><code>local class = ClassPP.class\n\nlocal Student = class \"Student\" {\n    Public = {\n        -- Getter method for name\n        getName = function(self)\n            return self.Name\n        end,\n\n        -- Setter method for name\n        setName = function(self, name)\n            self.Name = name\n        end,\n\n        -- Getter method for age\n        getAge = function(self)\n            return self.Age\n        end,\n\n        -- Setter method for age\n        setAge = function(self, age)\n            if age &gt; 0 then\n                self.Age = age\n            end\n        end\n    },\n\n    Private = {\n        Name = \"\",\n        Age = 0\n    }\n}\n</code></pre> <p>In the example above, the <code>Student</code> class has private members called \"Name\" and \"Age\". The setter for the member \"Age\" includes a basic validation check. Using these getter and setter methods, we are able to access the values for these members.</p>"},{"location":"tutorials/best-practices/encapsulation/#tips","title":"Tips","text":"<p>If you want to implement encapsulation, make sure all the important data are set as private, to protect them from external modification. Using getter and setter methods for that data will allow for a much safer experience while allowing flexibility in changing the internal implementation. Like in the example on the previous section, also implementing validation checks will greatly improve data integrity.</p>"},{"location":"tutorials/best-practices/errorHandling/","title":"Error Handling","text":"<p>Class++ is designed in a way that makes class and object access safe and optimized. But unfortunately, it cannot stop errors occuring in your program altogether. For example, it cannot stop you from trying to access private or non-existent data.</p> <p>So it is up to you to be able to deal with the errors that occur while the program is running.</p>"},{"location":"tutorials/best-practices/errorHandling/#error-types","title":"Error Types","text":"<p>In Class++ there are two types of errors that can occur during runtime: Fatal and Non-Fatal.</p>"},{"location":"tutorials/best-practices/errorHandling/#fatal-errors","title":"Fatal Errors","text":"<p>Fatal errors are the type of errors that will completely crash your program. These errors are the most dangerous ones, naturally.</p> <p>Info</p> <p>Fatal errors in Luau can normally be created by using the built-in <code>error()</code> function:</p> <pre><code>error(\"This will error!\") -- Halts the execution, and prints the stack to the output.\n</code></pre> <p>In Class++, a fatal error will occur if you encounter a set limitation. For example, if you try to access a private member outside of a class method, it will cause a fatal error.</p> <pre><code>-- Assuming this is the main thread of the script.\nlocal newObject = class.new()\nnewObject.PrivateProperty = \"Hello!\" -- Will cause a fatal error.\n</code></pre>"},{"location":"tutorials/best-practices/errorHandling/#non-fatal-errors","title":"Non-Fatal Errors","text":"<p>Non-Fatal errors are the type of errors that will not crash your program. While less dangerous, this still does not mean that your program will continue to work as expected. For example, if a <code>destructor</code> function fails to run, Class++ will still destroy the object, while ensuring the program keeps running. But this does not mean that destructor has ran correctly, and there might be an object or a system that could not be cleared up, thus causing a memory leak.</p> <pre><code>local newClass = class \"Test\" {\n    destructor = function(self)\n        error(\"An unknown error occured!\")\n        self.object:Destroy() -- This line will never be reached, causing the object to never be destroyed!\n    end,\n    Public = {\n        object = {}\n    }\n}\n</code></pre>"},{"location":"tutorials/best-practices/errorHandling/#tips","title":"Tips","text":"<p>Be careful. To ensure your program is running safely, every operation that can fail should be put inside either a <code>pcall()</code> or a <code>xpcall()</code>. These functions allow you to safely handle any errors that may occur in your code.</p> <p>A full list of fatal and non-fatal errors can be found in the Errors page.</p>"},{"location":"tutorials/best-practices/optimization/","title":"Optimization","text":"<p>Class++ is designed to be as optimized as possible for a class and objects system. To achieve the best performance, you can avoid certain scenarios that will slow Class++ down.</p>"},{"location":"tutorials/best-practices/optimization/#skipping-operations","title":"Skipping Operations","text":"<p>Class++ will skip certain unnecessary operations made by the user. For example, if you try to set a value to a member that is exactly the same as the one the member had before, Class++ will skip this operation.</p> <pre><code>local newClass = class \"Test\" {\n    Public = {\n        test = \"hello\"\n    }\n}\n\nlocal newObject = newClass.new()\nnewObject.test = \"hello\" -- This operation will be skipped.\n</code></pre> <p>However, you still shouldn't trust on Class++ to skip these operations, as it will still try to check if the thread is able to access the member or not. To get the best performance, avoid setting member values to the same values as before.</p>"},{"location":"tutorials/best-practices/optimization/#accessing-members","title":"Accessing Members","text":"<p>Now, accessing members in Class++ is very fast*, and you should not worry about performance. However, if you still want to gain the best amount of performance, here are some things you can do:</p> <ol> <li>Always access private members from class functions. This allows Class++ to achieve the best performance when achieving the member values. This also supports encapsulation, and will encourage you to adopt coding styles that will be the best for you in the long-run.</li> <li>Use public members when necessary. If a member does not contain important data or is an interface, then it should be a public member. This greatly increases the performance when accessing that member, and also promotes a better coding style.</li> </ol> <p>Class++ is very flexible and tries to be as lightweight as possible. Always avoid using systems or patterns that will both slow Class++, and your own methods down. You can check out other pages of the Tutorial to adapt the recommended patterns and syntax.</p> *: About 3 \u03bcs (3 microseconds)"},{"location":"tutorials/best-practices/polymorphism/","title":"Polymorphism","text":"<p>In simple terms, Polymorphism stands for \"many forms\", it's one of the core concepts of OOP. It refers to situations where something occurs in several different forms, and describes the concept that you can access objects of different types through the same interface.</p> <p>Function Overloading, Operator Overloading, and Inheritance belong to this concept, for example with inheritance, we can create derived classes that have the same method name, but all do different things. Or with function overloading, every function has different arguments and does a different thing, but all share the same name. It provides flexibility, and extensibility.</p>"},{"location":"tutorials/best-practices/polymorphism/#inheritance-example","title":"Inheritance Example","text":"<pre><code>local class = ClassPP.class\n\nlocal Animal = class \"Animal\" {\n    Public = {\n        animalSound = function(self)\n            print(\"The animal makes a sound\")\n        end\n    }\n}\n\n-- Derived class\nlocal Pig = class \"Pig\" (Animal, nil) {\n    Public = {\n        animalSound = function(self)\n            print(\"The pig says: oink oink\")\n        end\n    }\n}\n\n-- Derived class\nlocal Dog = class \"Dog\" (Animal, nil) {\n    Public = {\n        animalSound = function(self)\n            print(\"The dog says: woof woof\")\n        end\n    }\n}\n</code></pre>"},{"location":"tutorials/best-practices/polymorphism/#function-overloading-example","title":"Function Overloading Example","text":"<pre><code>local class = ClassPP.class\n\nlocal Test = class \"Test\" {}\nTest.overload(\"Public\", \"Display\", {\n    function(self, number1)\n        print(\"Number: \", number1)\n    end,\n    function(self, number1, number2)\n        print(\"Numbers: \", number1, number2)\n    end\n})\n</code></pre>"}]}