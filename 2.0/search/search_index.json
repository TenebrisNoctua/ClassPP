{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#classppTitle","title":"Overload your Classes.","text":"<p>     Tired of the traditional class system on Roblox?     Tired of learning complex systems, and wish for something easier?     Wish to do OOP in the right way, like in many languages such as C++? </p> <p>     Then you're in the right place.     Introducing: Class++.     Classes were never this easy to create, and advanced before on Roblox. </p> Getting Started Download"},{"location":"api-reference/","title":"API Reference","text":"<p>Welcome to the API Reference section of Class++ !  This section is more technical, and is not recommended for beginners. Check out the tutorials for a guided experience!</p> <p>You can use the left bar to find the API members grouped by their category. Additionally, you can use the search bar to find a specific API member.</p>"},{"location":"api-reference/errors/","title":"Errors","text":"<p>When Class++ displays an error message to the output, it will have a short ID at the end. This allows you to identify what kind of error or message that is.</p> <p>You can use that ID to find the details about that error or message down below.</p>"},{"location":"api-reference/errors/#attempttomodifyreadonlytable","title":"attemptToModifyReadOnlyTable","text":"<pre><code>Cannot modify a read only table.\n</code></pre> <p>You've attempted modify a read-only table within Class++. This usually occurs when you try to modify the <code>Inherits</code>, <code>Friends</code> and <code>Statics</code> tables of a <code>class</code>.</p>"},{"location":"api-reference/errors/#attempttocreateobjectfromabstractclass","title":"attemptToCreateObjectFromAbstractClass","text":"<pre><code>Cannot create an object from an abstracted class.\n</code></pre> <p>You tried to create an <code>object</code> from an abstract <code>class</code>. Abstract classes are not meant to create objects from, rather, they are meant to be a base-class that a <code>class</code> inherits from.</p>"},{"location":"api-reference/errors/#attempttoextendafinalclass","title":"attemptToExtendAFinalClass","text":"<pre><code>Cannot create an inherited class from a final class.\n</code></pre> <p>You tried to create a <code>class</code> from a final <code>class</code>. Final classes are not meant to be inherited from.</p>"},{"location":"api-reference/errors/#cannotcallfunctionerror","title":"cannotCallFunctionError","text":"<pre><code>Cannot call function directly.\n</code></pre> <p>You've tried to call a function within a <code>class</code> without creating an <code>object</code>. Class functions are not meant to be used directly, rather, they are to be used from objects. (Excluding static members.)</p>"},{"location":"api-reference/errors/#classalreadyexists","title":"classAlreadyExists","text":"<pre><code>Class ... already exists.\n</code></pre> <p>You've tried to create a <code>class</code> that already has been created with the same name. Consider changing the name of the new <code>class</code>.</p>"},{"location":"api-reference/errors/#classclassdatainternal","title":"classClassDataInternal","text":"<pre><code>The property classData of the class ... is Internal. It cannot be used.\n</code></pre> <p>You've attempted to access the <code>classData</code> property of a <code>class</code> directly. This property is meant to be used internally, and is not meant for external use. This property only shows up in the auto-complete to support type-checking in certain cases.</p>"},{"location":"api-reference/errors/#classdatanottable","title":"classDataNotTable","text":"<pre><code>Given classData value for the class ... is not a table.\n</code></pre> <p>You've given a <code>classData</code> value that is not a table to the <code>class</code> function. The <code>class</code> function only takes a table as its <code>classData</code> parameter.</p>"},{"location":"api-reference/errors/#classdatacontainsmetatable","title":"classDataContainsMetatable","text":"<pre><code>Given classData value for the class ... contains a metatable.\n</code></pre> <p>You've given a <code>classData</code> value that contains a metatable attached to it. For security and performance reasons, <code>classData</code> parameter only takes a raw table without any metatables attached to it.</p>"},{"location":"api-reference/errors/#classmembercannotsettonil","title":"classMemberCannotSetToNil","text":"<pre><code>Class members cannot be set to nil.\n</code></pre> <p>You've attempted to set a class member within the <code>object</code> to nil. Setting member values to nil causes certain bugs to happen (due to the nature of dictionaries), so it is not allowed to set them to <code>nil.</code> Consider setting it to a value such as <code>false</code> to indicate that it is no longer in use.</p>"},{"location":"api-reference/errors/#classmembernotfound","title":"classMemberNotFound","text":"<pre><code>This class has no member named ...\n</code></pre> <p>You've tried to index the <code>object</code> with a member that does not exist within the <code>classData</code> table. Members can only be added or removed through changing the <code>classData</code> table given to the <code>class</code> function.</p>"},{"location":"api-reference/errors/#classnamenotstring","title":"classNameNotString","text":"<pre><code>Class name is not a string or is nil.\n</code></pre> <p>The <code>class</code> function expected a <code>string</code> as it's name, but you provided something else. A <code>class</code>'s name can only be a <code>string</code>. </p>"},{"location":"api-reference/errors/#classnotfound","title":"classNotFound","text":"<pre><code>A class with the given name cannot be found.\n</code></pre> <p>A <code>class</code> cannot be found with the provided name argument. Make sure the name is correct, or if the <code>class</code> actually exists.</p>"},{"location":"api-reference/errors/#classnomatchingfunctionerror","title":"classNoMatchingFunctionError","text":"<pre><code>No match for ... function in this class.\n</code></pre> <p>You've used an operator on an <code>object</code> which had no overloads set for it.</p>"},{"location":"api-reference/errors/#classobjectlocked","title":"classObjectLocked","text":"<pre><code>This class object has been locked.\n</code></pre> <p>You've tried to use an <code>object</code> after it's been locked.</p>"},{"location":"api-reference/errors/#classpropertyisprivate","title":"classPropertyIsPrivate","text":"<pre><code>Property ... is private in this class.\n</code></pre> <p>You've tried to access a private member of an <code>object</code> outside of a class function.</p>"},{"location":"api-reference/errors/#classpropertyisprotected","title":"classPropertyIsProtected","text":"<pre><code>Property ... is protected in this class.\n</code></pre> <p>You've tried to access a protected member of an <code>object</code> outside of a class function.</p>"},{"location":"api-reference/errors/#classpropertyisinternal","title":"classPropertyIsInternal","text":"<pre><code>Property ... is internal in this class. You cannot access it.\n</code></pre> <p>You've tried to access an internal member of an <code>object</code>. Internal members are not accessible.</p>"},{"location":"api-reference/errors/#classpropertyredeclaration","title":"classPropertyRedeclaration","text":"<pre><code>Cannot redeclare property ...\n</code></pre> <p>You've tried to declare a property that has already been declared in another access-specifier. You can only declare a member in one access-specifier.</p>"},{"location":"api-reference/errors/#expectedfunctionerror","title":"expectedFunctionError","text":"<pre><code>Expected function, got: ...\n</code></pre> <p>The <code>functionsTable</code> that you provided to <code>class.overload</code> function had a value that wasn't a function.</p>"},{"location":"api-reference/errors/#extendsdeprecated","title":"extendsDeprecated","text":"<pre><code>Extends is now deprecated. Use the \"class\" function instead.\n</code></pre> <p>You've tried to use the now deprecated <code>extends</code> function for inheritance. See the discussion <code>#4</code> for more info.</p>"},{"location":"api-reference/errors/#invalidaccessspecifiererror","title":"invalidAccessSpecifierError","text":"<pre><code>Given value is not a valid access specifier.\n</code></pre> <p>You've provided a value that wasn't a valid access specifier. Make sure the given <code>string</code> contains a valid access-specifier. </p>"},{"location":"api-reference/errors/#invalidaccessspecifierinclassdata","title":"invalidAccessSpecifierInClassData","text":"<pre><code>Given classData value for the class ... contains invalid access specifier(s) or function(s).\n</code></pre> <p>You've given a <code>classData</code> value that contains invalid access-specifiers or functions. Make sure the access-specifier or function names are correct.</p>"},{"location":"api-reference/errors/#invaliddestructordecleration","title":"invalidDestructorDecleration","text":"<pre><code>Cannot create reserved function \"Destroy\".\n</code></pre> <p>You've declared a member called \"Destroy\", that is already reserved for calling the <code>destructor</code>.</p>"},{"location":"api-reference/errors/#invalidsuperdecleration","title":"invalidSuperDecleration","text":"<pre><code>Cannot create reserved function \"super\".\n</code></pre> <p>You've declared a member called \"super\", that is already reserved for calling the <code>super</code> method.</p>"},{"location":"api-reference/errors/#invalidmodifierargument","title":"invalidModifierArgument","text":"<pre><code>Given argument is not a class table.\n</code></pre> <p>You've given a value to a modifier function that wasn't a table containing classes.</p>"},{"location":"api-reference/errors/#illegalmodifiercombination","title":"illegalModifierCombination","text":"<pre><code>Cannot create an illegal combination of modifiers: ...\n</code></pre> <p>You've tried to create an illegal combination of modifiers. Certain modifiers have opposite functionality, so combining them is not possible.</p>"},{"location":"api-reference/errors/#nonnativeoperatorcall","title":"nonNativeOperatorCall","text":"<pre><code>Operator function ... cannot be called without its operator.\n</code></pre> <p>You've tried to call an operator function without its operator. Operator functions are meant to be called with their operators.</p>"},{"location":"api-reference/errors/#overloadfunctionargumentmismatch","title":"overloadfunctionArgumentMismatch","text":"<pre><code>A function to handle the given number of arguments ... have not been provided for the overloaded function: ...\n</code></pre> <p>You haven't provided a function to the <code>functionsTable</code> to handle the given number of arguments for an overloaded function.</p>"},{"location":"api-reference/errors/#overloadfunctionnamenotset","title":"overloadfunctionNameNotSet","text":"<pre><code>A function name has not been set for the overloaded function.\n</code></pre> <p>You haven't provided a name for the overloaded function.</p>"},{"location":"api-reference/errors/#overloadfunctiontablenotgiven","title":"overloadfunctionTableNotGiven","text":"<pre><code>A function table has not been given for the overloaded function.\n</code></pre> <p>You haven't provided a <code>functionsTable</code> for the overloaded function.</p>"},{"location":"api-reference/errors/#staticmembernamenotset","title":"staticMemberNameNotSet","text":"<pre><code>A name has not been set for the static member.\n</code></pre> <p>You haven't provided a name for the static member.</p>"},{"location":"api-reference/errors/#typeofobjectnotfound","title":"typeofObjectNotFound","text":"<pre><code>The given object's type cannot be found.\n</code></pre> <p>The provided object's type cannot be found.</p>"},{"location":"api-reference/errors/#unknownerror","title":"unknownError","text":"<pre><code>An unknown error has occured.\n</code></pre> <p>Class++ ran into a problem, but it cannot associate it with a valid error type. This is meant to be a fallback error, and may only occur if the internal code isn't running properly.</p>"},{"location":"api-reference/classFunctions/mainModule/abstract/","title":"abstract :class","text":"<p><pre><code>function classpp.abstract(classTable: {class}): class\n</code></pre> Marks the given <code>class</code> or <code>class</code>es as abstract. If given multiple, then the first class will be returned.</p>"},{"location":"api-reference/classFunctions/mainModule/abstract/#default-syntax","title":"Default Syntax","text":"<pre><code>local Car = abstract { class \"Car\" {\n    Public = {\n        ...\n    },\n    ...\n}}\n</code></pre>"},{"location":"api-reference/classFunctions/mainModule/abstract/#without-syntax-sugar","title":"Without Syntax Sugar","text":"<pre><code>local Car = abstract({class(\"Car\")({\n    Public = {\n        ...\n    },\n    ...\n})})\n</code></pre>"},{"location":"api-reference/classFunctions/mainModule/abstract/#parameters","title":"Parameters","text":"<p> classTable: {class} The desired <code>class</code> or <code>class</code>es to be set to abstract. </p>"},{"location":"api-reference/classFunctions/mainModule/abstract/#returns","title":"Returns","text":"<p> class"},{"location":"api-reference/classFunctions/mainModule/class/","title":"class :class","text":"<pre><code>function classpp.class(className: string): (classData: classData) -&gt; class\n</code></pre> <p>Creates a new <code>class</code> with the given <code>classData</code> table.</p>"},{"location":"api-reference/classFunctions/mainModule/class/#default-syntax","title":"Default Syntax","text":"<pre><code>local Class = class \"Class\" {\n    constructor = function(self)\n        ...\n    end,\n    destructor = function(self)\n        ...\n    end,\n    Public = {\n        ...\n    },\n    Private = {\n        ...\n    },\n    Protected = {\n        ...\n    },\n    Friend = {\n        ...\n    }\n}\n</code></pre>"},{"location":"api-reference/classFunctions/mainModule/class/#without-syntax-sugar","title":"Without Syntax Sugar","text":"<pre><code>local Class = class(\"Class\")({\n    constructor = function(self)\n        ...\n    end,\n    destructor = function(self)\n        ...\n    end,\n    Public = {\n        ...\n    },\n    Private = {\n        ...\n    },\n    Protected = {\n        ...\n    },\n    Friend = {\n        ...\n    }\n})\n</code></pre>"},{"location":"api-reference/classFunctions/mainModule/class/#parameters","title":"Parameters","text":"<p> className: string An unique name for the <code>class</code>. inheritedClasses: ...class The <code>class</code>es the created <code>class</code> will inherit from. (Optional) classData: classData The <code>classData</code> table that contains the data such as access specifiers for the <code>class</code>."},{"location":"api-reference/classFunctions/mainModule/class/#returns","title":"Returns","text":"<p> class"},{"location":"api-reference/classFunctions/mainModule/final/","title":"final :class","text":"<pre><code>function classpp.final(classTable: {class}): class\n</code></pre> <p>Marks the given <code>class</code> or <code>class</code>es as final. If given multiple, then the first class will be returned.</p>"},{"location":"api-reference/classFunctions/mainModule/final/#default-syntax","title":"Default Syntax","text":"<pre><code>local Car = final { class \"Car\" {\n    Public = {\n        ...\n    },\n    ...\n}}\n</code></pre>"},{"location":"api-reference/classFunctions/mainModule/final/#without-syntax-sugar","title":"Without Syntax Sugar","text":"<pre><code>local Car = final({class(\"Car\")({\n    Public = {\n        ...\n    },\n    ...\n})})\n</code></pre>"},{"location":"api-reference/classFunctions/mainModule/final/#parameters","title":"Parameters","text":"<p> classTable: {class} The desired <code>class</code> or <code>class</code>es to be set to final. </p>"},{"location":"api-reference/classFunctions/mainModule/final/#returns","title":"Returns","text":"<p> class"},{"location":"api-reference/classFunctions/mainModule/getClass/","title":"getClass :class","text":"<pre><code>function classpp.getClass(className: string): class\n</code></pre> <p>Returns the <code>class</code> with the given <code>className</code>, if it exists.</p>"},{"location":"api-reference/classFunctions/mainModule/getClass/#default-syntax","title":"Default syntax","text":"<pre><code>local Class = ClassPP.getClass(\"Class\")\n</code></pre>"},{"location":"api-reference/classFunctions/mainModule/getClass/#parameters","title":"Parameters","text":"<p> className: string The name of the desired <code>class</code>. </p>"},{"location":"api-reference/classFunctions/mainModule/getClass/#returns","title":"Returns","text":"<p> class"},{"location":"api-reference/classFunctions/type/type/","title":"type :string","text":"<pre><code>function Type.type(object: any): string\n</code></pre> <p>Returns the true type of the given <code>object</code>. Behaves the same as the built-in <code>type()</code> function, but with additional support for <code>class</code>es and <code>object</code>s.</p>"},{"location":"api-reference/classFunctions/type/type/#default-syntax","title":"Default syntax","text":"<pre><code>local objectType = ClassPP.Type.type(object)\n</code></pre>"},{"location":"api-reference/classFunctions/type/type/#parameters","title":"Parameters","text":"<p> object: object The <code>object</code>. </p>"},{"location":"api-reference/classFunctions/type/type/#returns","title":"Returns","text":"<p> string"},{"location":"api-reference/classFunctions/type/typeof/","title":"typeof :string","text":"<pre><code>function Type.typeof(object: any): string\n</code></pre> <p>Returns the type of the given <code>object</code>. Behaves the same as the built-in Roblox <code>typeof()</code> function, but with additional support for <code>class</code>es and <code>object</code>s.</p>"},{"location":"api-reference/classFunctions/type/typeof/#default-syntax","title":"Default syntax","text":"<pre><code>local objectType = ClassPP.Type.typeof(object)\n</code></pre>"},{"location":"api-reference/classFunctions/type/typeof/#parameters","title":"Parameters","text":"<p> object: object The <code>object</code>. </p>"},{"location":"api-reference/classFunctions/type/typeof/#returns","title":"Returns","text":"<p> string"},{"location":"api-reference/classFunctions/util/checkFriendship/","title":"checkFriendship :boolean","text":"<pre><code>function Util.checkFriendship(class: class, methodName: string, method: () -&gt; (), classes: {[string]: class}): boolean\n</code></pre> <p>This function checks if the given <code>method</code> and it's <code>methodName</code> is in the given <code>class</code>'s <code>Friend</code> access specifier.</p>"},{"location":"api-reference/classFunctions/util/checkFriendship/#default-syntax","title":"Default syntax","text":"<pre><code>local isAFriend = ClassPP.Util.checkFriendship(class, methodName, method, classes)\n</code></pre>"},{"location":"api-reference/classFunctions/util/checkFriendship/#parameters","title":"Parameters","text":"<p> class: class The <code>class</code> that the check will be made from. methodName: string The name of the given <code>method</code>. class: class The <code>method</code> that will be checked. classes: {[string]: class} A table that contains all of the created <code>class</code>es. Since a <code>class</code> can also be inserted to the <code>Friend</code> access specifier through a <code>string</code> that contains the <code>class</code>'s name, this table is used to find the <code>class</code>es set with this method. </p>"},{"location":"api-reference/classFunctions/util/checkFriendship/#returns","title":"Returns","text":"<p> boolean"},{"location":"api-reference/classFunctions/util/checkInheritance/","title":"checkInheritance :boolean","text":"<pre><code>function Util.checkInheritance(class: class, classOrMethod: class | () -&gt; ()): boolean\n</code></pre> <p>If the <code>classOrMethod</code> is a <code>class</code>, the function checks if the given <code>class</code> has been inherited from <code>classOrMethod</code>, or if the <code>classOrMethod</code> is a method, then it simply checks if any of the classes that the given <code>class</code> inherits from contains the method.</p>"},{"location":"api-reference/classFunctions/util/checkInheritance/#default-syntax","title":"Default syntax","text":"<pre><code>local isInherited = ClassPP.Util.checkInheritance(classOne, classTwo) -- For classes\nlocal isInherited = ClassPP.Util.checkInheritance(class, method) -- For methods\n</code></pre>"},{"location":"api-reference/classFunctions/util/checkInheritance/#parameters","title":"Parameters","text":"<p> class: class The <code>class</code> that the check will be made from. classOrMethod: class | () -&gt;() The <code>class</code> or the <code>method</code> that will be checked. </p>"},{"location":"api-reference/classFunctions/util/checkInheritance/#returns","title":"Returns","text":"<p> boolean"},{"location":"api-reference/classFunctions/util/inClassScope/","title":"inClassScope :boolean","text":"<pre><code>function Util.inClassScope(class: class, includeInherited: boolean, includeFriend: boolean, classes: {[string]: class}?, defaultLevel: number?): boolean\n</code></pre> <p>This function checks if the current thread is allowed to access a specific <code>class</code> property from a certain access specifier.</p>"},{"location":"api-reference/classFunctions/util/inClassScope/#default-syntax","title":"Default syntax","text":"<pre><code>local isAllowed = Util.inClassScope(class, false, true, Classes) -- For the Private access specifier\n</code></pre>"},{"location":"api-reference/classFunctions/util/inClassScope/#parameters","title":"Parameters","text":"<p> class: class The <code>class</code> that the check will be made from. includeInherited: boolean Determines if the inherited <code>class</code>es can access. includeFriend: boolean Determines if the friend <code>class</code>es can access. classes: {[string]: class} A table that contains classes. If <code>includeFriend</code> is set to <code>true</code>, this table will be given to the Util.checkFriendship function. defaultLevel: number Determines the default call stack level the function will start doing the checks on. </p>"},{"location":"api-reference/classFunctions/util/inClassScope/#returns","title":"Returns","text":"<p> boolean"},{"location":"api-reference/dataTypes/class/","title":"Class","text":"<p>A <code>class</code> object created from the <code>class()</code> function. Contains all of the members given from the <code>classData</code>.</p> Summary Properties <ul> <li>Name: An unique identifier of the <code>class</code>.</li> <li>Inherits: A table that contains classes that the <code>class</code> inherits from.</li> <li>Friends: A table that contains functions or clases that can access the <code>Private</code> and the <code>Protected</code> members of the <code>class</code>. </li> <li>Statics:  A table that contains the static members of the <code>class</code>. These members can only be called through the <code>class</code> object.</li> </ul> Methods <ul> <li>new:  Returns a new <code>object</code> that contains all of the members given from the <code>class</code>.</li> <li>extends: Used to create a new <code>class</code> that inherits the <code>class</code> it's been created from. (Deprecated)</li> <li>overload: Creates an overloaded function with the given access specifier, name and the function table, and saves it to the <code>class</code>'s <code>classData</code>.</li> </ul>"},{"location":"api-reference/dataTypes/class/#properties","title":"Properties","text":""},{"location":"api-reference/dataTypes/class/#name-string","title":"Name              : string","text":"<p>This is an unique identifier of the <code>class</code>. Using the <code>getClass()</code> function with this property will retrieve the desired <code>class</code>. Since names are unique, for every class, you have to use a different name.</p>"},{"location":"api-reference/dataTypes/class/#inherits-class-read-only","title":"Inherits              : {class}      Read Only","text":"<p>This table contains all the classes that the <code>class</code> is inheriting from. </p>"},{"location":"api-reference/dataTypes/class/#friends-class-read-only","title":"Friends              : {class}      Read Only","text":"<p>This table contains all the functions and the classes that can access all of the <code>Public</code> and <code>Protected</code> members of the <code>class</code>.</p>"},{"location":"api-reference/dataTypes/class/#statics-string-any-read-only","title":"Statics              : {[string]: any}      Read Only","text":"<p>This table contains all the members that are static, meaning they only belong to the <code>class</code>. These members won't replicate to the  objects, and can only be called through the <code>class</code> object.</p>"},{"location":"api-reference/dataTypes/class/#methods","title":"Methods","text":""},{"location":"api-reference/dataTypes/class/#new-object","title":"new              : object","text":"<p>Creates and returns a new <code>object</code> that contains all of the members given from the <code>class</code>.</p>"},{"location":"api-reference/dataTypes/class/#returns","title":"Returns","text":"<p> object </p>"},{"location":"api-reference/dataTypes/class/#extends-void","title":"extends              : void","text":"<p>Used to create and return a new <code>class</code> that inherits the <code>class</code> it's been created from.</p> <p>Deprecated</p> <p>This method has been deprecated and should not be used for new work. Instead, use the <code>class</code> method.</p>"},{"location":"api-reference/dataTypes/class/#overload-void","title":"overload              : void","text":"<p>Creates an overloaded function with the given parameters, and saves it to the <code>class</code>'s <code>classData</code> table.</p>"},{"location":"api-reference/dataTypes/class/#parameters","title":"Parameters","text":"<p> accessSpecifier: string The access specifier of the overloaded function. name: string The name of the overloaded function. functionTable: {(...any) -&gt; (any)} The function table that contains all the functions with different amount of arguments for the overloaded function. </p>"},{"location":"api-reference/dataTypes/class/#returns_1","title":"Returns","text":"<p> void </p>"},{"location":"api-reference/dataTypes/class/#static-void","title":"static              : void","text":"<p>Creates a new static member with the given parameters, and saves it to the <code>class</code>'s <code>Statics</code> table. These members do not replicate to the objects, as they belong to the <code>class</code>. </p>"},{"location":"api-reference/dataTypes/class/#parameters_1","title":"Parameters","text":"<p> accessSpecifier: string The access specifier of the static member. name: string The name of the static member. property: any The property that will be saved to the static member. This property can then be accessed through indexing the <code>class</code> with the member name, such as: <code>class.memberName.property</code>. (Or <code>class.memberName.p</code>) </p>"},{"location":"api-reference/dataTypes/class/#returns_2","title":"Returns","text":"<p> void </p>"},{"location":"api-reference/dataTypes/object/","title":"Object","text":"<p>An <code>object</code> created from the <code>class.new()</code> function. Contains all of the members given from the <code>class</code> object.</p> <p>Warning</p> <p><code>object</code>s act as a proxy, as they belong to the base type <code>userdata</code>. They allow access to members in the <code>objectData</code>, but they cannot be changed. This is to make access-specifiers work in the best way possible.</p> Summary Properties <ul> <li>__locked: Indicates if the <code>object</code> is locked.</li> <li>__type: Indicates the type of the <code>object</code>.</li> <li>__objtype: Indicates the <code>class</code> type of the <code>object</code>.</li> </ul> Methods <ul> <li>constructor: The constructor function of the <code>object</code>, if it exists. Cannot be directly called.</li> <li>destructor: The destructor function of the <code>object</code>, if it exists. Cannot be directly called.</li> <li>Destroy: Calls the <code>destructor</code> function, destroys all the instances inside the <code>objectData</code> and clears it, and sets the <code>__locked</code> property to <code>true</code>.</li> <li>super: Calls the method with the same name of the function that it's been called from in the parent <code>class</code>, if it exists.</li> </ul>"},{"location":"api-reference/dataTypes/object/#properties","title":"Properties","text":""},{"location":"api-reference/dataTypes/object/#__locked-boolean-internal","title":"__locked              : boolean      Internal","text":"<p>Indicates if an <code>object</code> has been locked. If set to true, the <code>object</code>'s metamethods will no longer work and all the members will become unaccessable. </p>"},{"location":"api-reference/dataTypes/object/#__type-string-internal","title":"__type              : string      Internal","text":"<p>Indicates the type of the <code>object</code>. For <code>object</code>s created from <code>class.new()</code>, it will always be \"Object\".</p>"},{"location":"api-reference/dataTypes/object/#__objtype-string-internal","title":"__objtype              : string      Internal","text":"<p>Indicates the <code>class</code> type of the <code>object</code>. Can be used to determine which <code>class</code> the <code>object</code> belongs to by using the <code>Type.typeof()</code> function.</p>"},{"location":"api-reference/dataTypes/object/#methods","title":"Methods","text":""},{"location":"api-reference/dataTypes/object/#constructor-void-internal","title":"constructor              : void      Internal","text":"<p>The <code>constructor</code> function of the <code>object</code>, if it has been set in the <code>classData</code> table. This function is internal, and it will only be called when the <code>object</code> is created by using the <code>class.new()</code> function.</p>"},{"location":"api-reference/dataTypes/object/#returns","title":"Returns","text":"<p> void </p>"},{"location":"api-reference/dataTypes/object/#destructor-void-internal","title":"destructor              : void      Internal","text":"<p>The <code>destructor</code> function of the <code>object</code>, if it has been set in the <code>classData</code> table. This function accepts no parameters and is internal, it will only be called when <code>object:Destroy()</code> is called. </p>"},{"location":"api-reference/dataTypes/object/#returns_1","title":"Returns","text":"<p> void </p>"},{"location":"api-reference/dataTypes/object/#destroy-void","title":"Destroy              : void","text":"<p>Calling this method will destroy and clean the <code>object</code>. This method will first trigger the <code>destructor</code> function, then after, it will clear the internal <code>objectData</code> table and set the <code>__locked</code> property of the <code>object</code> to <code>true</code>. Instances inside <code>objectData</code> will automatically be destroyed and cleared too.</p> <p>After this function runs, the <code>object</code> will no longer be accessible in any way, so make sure to remove all references to the <code>object</code> to allow for the garbage collector to clear it. This prevents memory leaks.</p>"},{"location":"api-reference/dataTypes/object/#returns_2","title":"Returns","text":"<p> void </p>"},{"location":"api-reference/dataTypes/object/#super-any","title":"super              : any","text":"<p>This method allows you to refer to the parent <code>class</code>'s methods. Calling this method will call the function with the same name as the function it's been called from in the parent <code>class</code>, if it exists, and return the result.</p> <p>Warning</p> <p><code>super</code> does not support being called in <code>class</code>es created from multi-inheritance, as it would create ambiguity. It also does not support calling functions that are defined in the <code>Private</code> access-specifier in the parent <code>class</code>.</p>"},{"location":"api-reference/types/classData/","title":"classData","text":"<pre><code>export type classData = {\n    constructor: (self: any, ...any) -&gt; ()?,\n    destructor: (self: any) -&gt; ()?,\n    Public: {[string]: any}?,\n    Private: {[string]: any}?,\n    Protected: {[string]: any}?,\n    Friend: {any}?\n}\n</code></pre> <p>The <code>classData</code> table that is given to the <code>class()</code> function that contains data about the desired <code>class</code>.</p>"},{"location":"api-reference/types/classData/#properties","title":"Properties","text":""},{"location":"api-reference/types/classData/#constructor-self-any-any-","title":"constructor              : (self: any, ...any) -&gt; ()?","text":"<p>The <code>constructor</code> function that will be called when an <code>object</code> gets created.</p>"},{"location":"api-reference/types/classData/#destructor-self-any-","title":"destructor              : (self: any) -&gt; ()?","text":"<p>The <code>destructor</code> function that will be called when an <code>object</code> gets destroyed.</p>"},{"location":"api-reference/types/classData/#public-string-any","title":"Public              : {[string]: any}?","text":"<p>The access specifier that contains properties that can be globally accessable.</p>"},{"location":"api-reference/types/classData/#private-string-any","title":"Private              : {[string]: any}?","text":"<p>The access specifier that contains properties that can only be accessed inside the <code>class</code>.</p>"},{"location":"api-reference/types/classData/#protected-string-any","title":"Protected              : {[string]: any}?","text":"<p>The access specifier that contains properties that can only be accessed inside the <code>class</code> and inherited classes.</p>"},{"location":"api-reference/types/classData/#friend-any","title":"Friend              : {any}?","text":"<p>The access specifier that contains functions and classes that can access the <code>class</code>'s <code>Private</code> properties.</p>"},{"location":"tutorials/","title":"Getting Started","text":"<p>Welcome to the tutorial section of Class++ !  Here, you will learn what you need to install Class++, how to install it, and how to create a basic testing script.</p>"},{"location":"tutorials/#requirements","title":"Requirements","text":"<p>To use Class++, you don't need to be an expert developer, all you need is:</p> <ul> <li>Basic understanding on the concept of OOP (Object Oriented Programming), and Classes.</li> <li>Understanding on how metatables work in Roblox.</li> </ul> <p>Basically, if you're already experienced with OOP, you're good to go!  Especially, if you already have knowledge in languages like C++ and Java, your job will be pretty easy.</p>"},{"location":"tutorials/#installation","title":"Installation","text":"<p>Installing Class++ is pretty easy! Just head over to this link to download the <code>ModuleScript</code>.</p> <p>After the download, open Roblox Studio, go into the place that you want to import Class++ to and right click on the <code>ReplicatedStorage</code> (or the location that you want to insert into), and select \"Insert from File\".</p> <p>Select the <code>Class++.rbxm</code> file that you just downloaded, and if the <code>ModuleScript</code> has appeared, congratulations, the Installation is complete!</p>"},{"location":"tutorials/#creating-a-testing-script","title":"Creating A Testing Script","text":"<p>Now that you installed Class++, we can create a script to test if it has been successfully installed:</p> <ul> <li>1: Create a <code>Script</code> or a <code>LocalScript</code> instance, and parent it to <code>workspace</code> or <code>StarterPlayer &gt; StarterPlayerScripts</code>.</li> <li>2: Remove the <code>print(\"Hello World\")</code> line, and paste the following code in:</li> </ul> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal ClassPP = require(ReplicatedStorage[\"Class++\"])\nlocal class = ClassPP.class\n</code></pre> <ul> <li>3: Press \"Play\" or \"Run\". If everything is working properly and there are no errors, you're good to go!</li> </ul>"},{"location":"tutorials/accessSpecifiers/","title":"Access Specifiers","text":"<p>Unlike any other class module or system on Roblox, Class++ comes with an Access Specifier system, like in C++, it provides you a way to modify the access control of a member. There are currently 4 access specifiers in Class++: <code>Public</code>, <code>Private</code>, <code>Protected</code>, and <code>Friend</code>. (You will learn about <code>Protected</code> and <code>Friend</code> later.)</p>"},{"location":"tutorials/accessSpecifiers/#public-access-specifier","title":"Public Access Specifier","text":"<p>Like you have seen in the examples on the previous pages, a Public access specifier allows anyone to access a member. Whether it be from a function inside the class or from the script's main thread, the member is accessible and can be modified.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    }\n}\n\nlocal newCar = Car.new()\nnewCar.Brand = \"Tesla\"\n</code></pre> <p>In this example, we created a new class with a Public member <code>Brand</code> that has the default value of <code>Lamborghini</code>. Then we created a new object from this class and modified the <code>Brand</code> member of this object. Now the value is set to <code>Tesla</code>.</p>"},{"location":"tutorials/accessSpecifiers/#private-access-specifier","title":"Private Access Specifier","text":"<p>Private access specifier allows you to hide a member from anyone outside from that class. No one besides the class members can access this member or modify it.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal newCar = Car.new()\nnewCar.License_Plate = \"YYYY\" -- This will error!\n</code></pre> <p>In this example, we updated the previous class with a private member named <code>License_Plate</code>, this member is private and can only be accessed by the class members, so trying to access or modify it outside of the class will cause an error.</p> <p>Warning</p> <p>A member (property/attribute) can be declared only once. This means a member can only be defined under one access specifier. Attempting to declare another member with the same name on a different access specifier will error.</p>"},{"location":"tutorials/classConstructors/","title":"Class Constructors and Destructors","text":"<p>Up until this point, when we created an object from a class, we always updated the object outside of the class, and we had to define a custom function every single time if we wanted to update or access a private member. This is the same for when we want to destroy an object too. This can be tedious after some time, as constantly having to do these steps over and over again for each class will get tiring. Fortunately, to solve these issues, there are 2 special functions that you can define in every class: <code>constructor</code> and <code>destructor</code>.</p>"},{"location":"tutorials/classConstructors/#class-constructors","title":"Class Constructors","text":"<p>A constructor is a special function that gets called when an object is created. To create a constructor, you have to specifically define a function called <code>constructor</code> outside of the Access Specifiers.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    constructor = function(self)\n        self.License_Plate = \"YYYY\"\n    end,\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal newCar = Car.new()\n</code></pre> <p>When <code>Car.new()</code> is called, the function will automatically call the constructor function. </p>"},{"location":"tutorials/classConstructors/#constructor-parameters","title":"Constructor Parameters","text":"<p>Constructors, like regular class functions, take parameters. (Just like regular class functions, the first argument will always be self.) This can be useful for setting inital values for certain members.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    constructor = function(self, brand, model, licensePlate)\n        self.License_Plate = licensePlate\n        self.Brand = brand\n        self.Model = model\n    end,\n    Public = {\n        Brand = \"\",\n        Model = \"\",\n        License_Plate = \"\"\n    },\n}\n\nlocal newCar = Car.new(\"ABCD\", \"Ford\", \"Mustang\")\nprint(newCar.Brand, newCar.Model, newCar.License_Plate) -- Prints \"ABCD, Ford, Mustang\"!\n</code></pre>"},{"location":"tutorials/classConstructors/#class-destructors","title":"Class Destructors","text":"<p>A destructor is a special function that runs when you call <code>:Destroy()</code> on an object. To create a destructor, you have to specifically define a function called <code>destructor</code> outside of the Access Specifiers.</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    constructor = function(self, brand, model, licensePlate)\n        self.License_Plate = licensePlate\n        self.Brand = brand\n        self.Model = model\n    end,\n    destructor = function(self)\n        self.License_Plate = \"\"\n        self.Brand = \"\"\n        self.Model = \"\"\n    end,\n    Public = {\n        Brand = \"\",\n        Model = \"\",\n        License_Plate = \"\"\n    },\n}\n\nlocal newCar = Car.new(\"ABCD\", \"Ford\", \"Mustang\")\nprint(newCar.Brand, newCar.Model, newCar.License_Plate)\n\nnewCar:Destroy() -- The class object will now be destroyed\nnewCar = nil\n</code></pre> <p>Info</p> <p>Unlike <code>constructor</code>, the <code>destructor</code> function does not take additional parameters, and the only argument will be the self pointing to the object. After the destructor is called, all the members inside the object will be set to nil (Instances inside are automatically destroyed and set to nil too), and the object will be locked, preventing any further access. At this stage, it would be best to set the object variable to nil, so the garbage collector can collect it and prevent memory leaks.</p> <p>Info</p> <p>Constructor and Destructor functions can also be written in the outside class definition syntax.</p>"},{"location":"tutorials/classCreation/","title":"Classes and Objects","text":"<p>A class is an user defined data structure. It's made out of members and member functions. Those members and member functions can be then accessed by creating an object from that class. Think of a class as a blueprint for an object.</p>"},{"location":"tutorials/classCreation/#creating-a-class","title":"Creating a Class","text":"<p>Here's an example of a person class:</p> <p><pre><code>local class = ClassPP.class\n\nlocal person = class \"Person\" {\n    Public = {\n        Name = \"\",\n        Age = 0\n    }\n}\n</code></pre> To create a new class, you use the <code>class()</code> function, with the above syntax, the first argument will be a string that defines the name of the class, and the second argument is the class data, a table that contains all the access specifiers and the member data.</p> <p>In the above example, we created a new class with the name <code>Person</code>, and we created two members, named: <code>Name</code> and <code>Age</code>.  Then, we assigned default values to them. These values will be transferred to the object when it gets created.</p>"},{"location":"tutorials/classCreation/#creating-an-object","title":"Creating an Object","text":"<p>Now that you have learned how to create classes, it's time to learn how to create objects. In Class++, to create an object you use the <code>class.new()</code> function. This function returns an object created from this class, and will contain all of the members that you defined.</p> <pre><code>local class = ClassPP.class\n\nlocal person = class \"Person\" {\n    Public = {\n        Name = \"\",\n        Age = 0\n    }\n}\n\nlocal newPerson = person.new()\nprint(newPerson.Age) -- Prints \"0\"!\n</code></pre> <p>Objects will have the members and their default values that you've set in the class data table, so if you want to update them, you can simply index the object with the member and set it to something else!</p> <pre><code>local class = ClassPP.class\n\nlocal person = class \"Person\" {\n    Public = {\n        Name = \"\",\n        Age = 0\n    }\n}\n\nlocal newPerson = person.new()\nnewPerson.Age = 21\n\nprint(newPerson.Age) -- Prints \"21\"!\n</code></pre> <p>Warning</p> <p>Unlike the classic class method on Roblox that developers use, in Class++, to define a member you must do it through the <code>class()</code> function, trying to define a new member through the object will result in an error.</p> <pre><code>local class = ClassPP.class\n\nlocal person = class \"Person\" {\n    Public = {\n        Name = \"\",\n        Age = 0\n    }\n}\n\nlocal newPerson = person.new()\nnewPerson.Personality = \"Cheerful\" -- This will error! This class has no member named \"Personality\".\n</code></pre>"},{"location":"tutorials/classMethods/","title":"Class Functions","text":"<p>Just like in C++, there are two ways to define a function(method) inside a class:</p> <ul> <li>Inside class definition</li> <li>Outside class definition</li> </ul>"},{"location":"tutorials/classMethods/#inside-class-definition","title":"Inside Class Definition","text":"<pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n        getLicensePlate = function(self)\n            print(self.License_Plate)\n        end\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n</code></pre> <p>In this example, we have defined a function inside the Public Access Specifier called <code>getLicensePlate</code>, this function when called will print the license plate of our object. </p> <p>Functions inside a class will always have <code>self</code> as their first argument. You can think of <code>self</code> as a pointer to the object. You can use it to access the object itself.</p> <p>Now, let's create an object from this class:</p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n        getLicensePlate = function(self)\n            print(self.License_Plate)\n        end\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal newCar = Car.new()\nnewCar:getLicensePlate()\n</code></pre> <p>You can notice that instead of calling the function with <code>.</code> operator, we used <code>:</code> operator. This is because of the first argument always being <code>self</code>. Calling the function with a <code>.</code> operator will cause the <code>self</code> to not exist, so you must either call the function with the object as its first argument, or use <code>:</code> operator, as it makes it easier.</p>"},{"location":"tutorials/classMethods/#functions-with-multiple-parameters","title":"Functions with multiple parameters","text":"<pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n        getLicensePlate = function(self, number)\n            print(self.License_Plate, number) -- Prints \"XXXX 1\"!\n        end\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal newCar = Car.new()\nnewCar:getLicensePlate(1) -- Calling the function with an argument\n</code></pre> <p>Like in this example, you can call functions with multiple parameters.   Since <code>self</code> is the first argument, all the other arguments that come after will start at 2. This will be important in later pages.</p>"},{"location":"tutorials/classMethods/#outside-class-definition","title":"Outside Class Definition","text":"<p>To define a function outside of the class, you must define it as: <code>function Class.&lt;accessSpecifier&gt;:&lt;functionName&gt;</code></p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nfunction Car.Public:getLicensePlate(number)\n    print(self.License_Plate, number) -- Prints \"XXXX 1\"!\nend\n\nlocal newCar = Car.new()\nnewCar:getLicensePlate(1)\n</code></pre> <p>In this example, we defined a function outside of the class by specifying the class name, then the access specifier, followed by the <code>:</code> operator and the name of the function. Unlike in C++, you do not have to define the function first inside the class to use this method.</p> <p>Info</p> <p>Outside Class Definition syntax is recommended as it allows for a better formatting style.</p>"},{"location":"tutorials/friendAccessSpecifier/","title":"Friend Access Specifier","text":"<p>Friend access specifier allows anyone defined in that access specifier to access the private members of a class.</p> <p>Warning</p> <p>Members of this access specifier will not be replicated to objects, rather, these members are stored in the class itself, and they can only be used to access the members in other access specifiers through objects.</p> <pre><code>local function getLicensePlate(object: any)\n    print(object.License_Plate)\nend\n\nlocal class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Private = {\n        License_Plate = \"XXXX\"\n    },\n    Friend = {\n        getLicensePlate\n    }\n}\n\nlocal newCar = Car.new()\ngetLicensePlate(newCar)\n</code></pre> <p>In this example, we updated the previous class to include a function in the <code>Friend</code> access specifier, this function is now able to access the private members of this class. </p> <p>Info</p> <p>Aside from functions, <code>Friend</code> access specifier can include other classes as well. Classes can be saved by using their variables, or their names. You can put a string inside the <code>Friend</code> access specifier that has the class's name, and it will still work!</p>"},{"location":"tutorials/functionOverloading/","title":"Function Overloading","text":"<p>Just like in many languages such as C++, Class++ supports function overloading.  Function Overloading is a feature where multiple functions can share the same name, but they are different from each other with different amount of arguments.</p> <p>To do function overloading in Class++, you have to use the <code>class.overload(&lt;accessSpecifier&gt;, &lt;name&gt;, &lt;functionTable&gt;)</code> function.</p> <pre><code>local class = ClassPP.class\n\nlocal Test = class \"Test\" {\n    Public = {\n        ValueA = 0,\n        ValueB = 0\n    }\n}\n\nTest.overload(\"Public\", \"Set\", {\n    function(self, a, b)\n        print(a, b)\n        self.ValueA = a\n        self.ValueB = b\n    end,\n    function(self, a)\n        print(a)\n        self.ValueA = a\n    end,\n    function(self)\n        print(self.ValueA, self.ValueB)\n    end\n})\n\nlocal newTest = Test.new()\nnewTest:Set(1, 2) -- Prints \"1 2\"\nnewTest:Set(3) -- Prints \"3\"\nnewTest:Set() -- Prints \"3 2\"\n</code></pre> <p>In this example, to create an overloaded function, we used the <code>.overload()</code> function with the <code>Public</code> access specifier, and <code>Set</code> for the function name. Then we gave a table with multiple functions with different arguments that each do a different thing. When we call the <code>:Set()</code> function through the object, depending on the amount of the given arguments, only the function that accepts the same amount of arguments will be ran.</p> <p>Warning</p> <p>Giving multiple functions that have the same amount of arguments will cause only one of these functions to be ran. Only create one function for a specific amount of arguments.</p>"},{"location":"tutorials/inheritance/","title":"Inheritance","text":"<p>Just like in C++ and many other languages, Class++ allows you to inherit classes.  We group the inheritance concept into two categories: derived class (child), and the base class (parent).</p> <pre><code>local class = ClassPP.class\n\nlocal Vehicle = class \"Vehicle\" { -- Base Class\n    Public = {\n        Brand = \"Tesla\",\n        Model = \"S\",\n        License_Plate = \"BITE 1987\",\n        Year = 2012,\n        honk = function(self)\n            print(\"honk honk!\")\n        end\n    }\n}\n\nlocal Car = class \"Car\" (Vehicle, nil) { -- Derived Class\n    Public = {\n        License_Plate = \"A1B2C3\"\n    }\n}\n\nlocal newCar = Car.new()\nnewCar:honk()\nprint(newCar.Brand, newCar.Model, newCar.License_Plate, newCar.Year) -- Prints \"Tesla S A1B2C3 2012\"!\n</code></pre> <p>In this example, we have 2 classes: The Vehicle class (base), and the Car class (child).  We created the Car class by providing the <code>class</code> function a list of classes to inherit from (in this case, only the Vehicle class), and the <code>classData</code> table after.</p> <p>When you create a class using this method, you create a new derived class that inherits all of the members and member functions from the class(es) provided, so you don't need to re-declare them again. The members are overwritable in the derived class, like in the example above, you can modify the <code>License_Plate</code>'s default value to anything you wish. The same applies to other members.</p> <p>Question</p> <p>\"Why should I use Inheritence?\" It's very useful for code reusability: reusing members and functions of an existing class when you're creating a new class will save you a lot of time and effort, defining same members over and over again may cause spaghetti code and decrease code readability.</p>"},{"location":"tutorials/inheritance/#multilevel-inheritance","title":"Multilevel-Inheritance","text":"<p>A class can also be derived from one class, which can be derived from another class:</p> <pre><code>local class = ClassPP.class\n\nlocal Person = class \"Person\" { -- Base Class\n    Public = {\n        Name = \"\",\n        Age = 0,\n        Gender = \"\",\n        Height = 0\n    }\n}\n\nlocal Child = class \"Child\" (Person, nil) { -- Derived Class\n    Public = {\n        Age = 9,\n        Energetic = true\n    }\n}\n\nlocal Student = class \"Student\" (Child, nil) { -- Derived Class from a Derived Class\n    Public = {\n        SchoolId = 0,\n        Grade = 0,\n        Behaviour = \"Good\"\n    }\n}\n\nlocal newStudent = Student.new()\nprint(newStudent.Name, newStudent.Age, newStudent.Gender, newStudent.Height, newStudent.Age, newStudent.Energetic, newStudent.SchoolId, newStudent.Grade, newStudent.Behaviour)\n-- Prints \" 9  0 9 true 0 0 Good\"! (Spaces represent empty strings)\n</code></pre>"},{"location":"tutorials/inheritance/#multi-inheritance","title":"Multi-Inheritance","text":"<p>A class can also be derived from multiple classes:</p> <pre><code>local class = ClassPP.class\n\nlocal A = class \"A\" { \n    Public = {\n        Variable_A = 1\n    }\n}\n\nlocal B = class \"B\" { \n    Public = {\n        Variable_B = 1\n    }\n}\n\nlocal C = class \"C\" (A, B) { -- Derived Class\n    Public = {\n        Variable_C = 1\n    }\n}\n\nlocal newObject = C.new() -- {Variable_A: number, Variable_B: number, Variable_C: number}\n</code></pre>"},{"location":"tutorials/inheritance/#protected-access-specifier","title":"Protected Access Specifier","text":"<p>In the Access Specifiers section, you have learned that there are 4 access specifiers in Class++, so far you have seen <code>Public</code>, <code>Private</code> and <code>Friend</code>. The fourth specifier, <code>Protected</code>, is pretty much the same as the <code>Private</code>, however, aside from the class members, inherited classes will also be able to access these members. </p> <pre><code>local class = ClassPP.class\n\nlocal Car = class \"Car\" {\n    Public = {\n        Brand = \"Lamborghini\",\n    },\n    Protected = {\n        License_Plate = \"XXXX\"\n    }\n}\n\nlocal BiggerCar = class \"BiggerCar\" (Car, nil) {\n    Public = {\n        Brand = \"Tesla\"\n    }\n}\n\nfunction BiggerCar.Public:printLicensePlate()\n    print(self.License_Plate) -- Will print \"XXXX\"!\nend\n\nlocal newCar = BiggerCar.new()\nnewCar:printLicensePlate()\n</code></pre> <p>In this example, we put the member <code>License_Plate</code> under the <code>Protected</code> access specifier, and created a new class inherited from the Car class. The inherited class and it's member functions will now be able to access this member. </p>"},{"location":"tutorials/inheritance/#super","title":"super","text":"<p>Let's say that you want to access a function in the base class from a child class, how would you do it? Creating a new object from the base class and calling the function would be tedious, as it would take longer to write and would decrease performance.</p> <p>Luckily, in Class++ 2.0, you can call the <code>super</code> method of the object, which allows you to call the function in the base class that has the same name of the function this method has been called from.</p> <pre><code>local class = ClassPP.class\n\nlocal A = class \"A\" { \n    Public = {\n        getVariable = function(self)\n            return self.Variable_A\n        end\n    },\n    Protected = {\n        Variable_A = 1\n    }\n}\n\nlocal B = class \"B\" (A, nil) { \n    Public = {\n        Variable_B = 1,\n        getVariable = function(self)\n            return self:super()\n        end\n    }\n}\n\nlocal newObject = B.new()\nprint(newObject:getVariable()) -- 1\n</code></pre> <p>In this example, we created a new class called \"B\" that inherits from \"A\". In both classes, we have a function called \"getVariable\", in the base class, this function returns the \"Variable_A\" member's value, and in the child class, this function returns the value from the \"getVariable\" function from the parent class, by calling the <code>super()</code> method. </p> <p>Warning</p> <p><code>super</code> cannot be used within classes that have multi-inheritance. This is due to ambiguity that occurs with functions that have the same name in classes that have multi-inheritance. </p>"},{"location":"tutorials/nonAccessSpecifiers/","title":"Non-Access Specifiers","text":"<p>Unlike access specifiers, non-access specifiers do not modify the access control of a member, but rather provide other functionality for classes.</p>"},{"location":"tutorials/nonAccessSpecifiers/#final","title":"Final","text":"<p>Using this non-access specifier will make the given class final, meaning this class now cannot be inherited by other classes.</p> <pre><code>local class, final = ClassPP.class, ClassPP.final\n\nlocal Car = final { class \"Car\" {\n    Public = {\n        Brand = \"Ford\",\n    }\n}}\n\nlocal BiggerCar = class \"BiggerCar\" (Car, nil) { -- This will error!\n    Public = {\n        Brand = \"Tesla\"\n    }\n}\n</code></pre>"},{"location":"tutorials/nonAccessSpecifiers/#abstract","title":"Abstract","text":"<p>Using this non-access specifier will make the given class an abstract class, meaning this class now cannot be used to create objects. To access an abstract class, it must be inherited from another class.</p> <pre><code>local class, abstract = ClassPP.class, ClassPP.abstract\n\nlocal BaseCar = abstract { class \"BaseCar\" {\n    Public = {\n        Brand = \"\",\n        Model = \"\",\n        Year = 0,\n        honk = function(self)\n            print(\"honk honk!\")\n        end\n    }\n}}\n\nlocal Car = class \"Car\" (BaseCar, nil) {\n    Public = {\n        Brand = \"Ford\",\n        Model = \"Mustang\",\n        Year = 2023\n    }\n}\n\nlocal newBaseCarObj = BaseCar.new() -- This will error!\nlocal newCarObj = Car.new() -- This will work fine!\nnewCarObj:honk()\n</code></pre> <p>Warning</p> <p>You cannot make a class both abstract and final, as they have opposite meanings. An abstract class must be subclassed, whereas a final class cannot be subclassed. Attempting to form an illegal combination between final and abstract methods will cause an error.</p>"},{"location":"tutorials/operatorOverloading/","title":"Operator Overloading","text":"<p>Suppose we have two objects that belong to a custom Vector class, how would we allow the addition of those two objects? Using normal class functions would be good, but it would take a longer time to write, and would be harder to understand.</p> <p>To solve this issue in Class++, just like in C++, we can change the way operators work for our classes. This is known as operator overloading.</p> <pre><code>local class = ClassPP.class\n\nlocal Vector = class \"Vector3\" {\n    constructor = function(self, x: number, y: number, z: number)\n        if typeof(x) ~= \"number\" or typeof(y) ~= \"number\" or typeof(z) ~= \"number\" then self.coordinates = {0, 0, 0} return end\n        self.coordinates = {x, y, z}\n    end,\n    Public = {\n        coordinates = {0, 0, 0},\n    },\n}\n\nfunction Vector.Public:operator_add(otherVector)\n    assert(#self.coordinates == #otherVector.coordinates)\n\n    local coordinates = {}\n\n    for i = 1, #self.coordinates do\n        coordinates[i] = self.coordinates[i] + otherVector.coordinates[i]\n    end\n\n    return Vector.new(coordinates[1], coordinates[2], coordinates[3])\nend\n\nfunction Vector.Public:__tostring()\n    return \"(\" .. table.concat(self.coordinates, \", \") .. \")\"\nend\n\nlocal vector1 = Vector.new(4, 5, 2)\nlocal vector2 = Vector.new(1, 2, 3)\n\nprint(vector1 + vector2) -- Prints \"(5, 7, 5)\"\n</code></pre> <p>In this example, we have created a custom Vector3 class that has a special function called <code>operator_add</code>, this special function is one of the special functions in Class++ that allows you to overload a specific operator. Here, we overloaded the operator <code>+</code> with our custom function that allows us to add two Vectors together.</p>"},{"location":"tutorials/operatorOverloading/#overloadable-operators","title":"Overloadable Operators","text":"Method Description <code>operator_add(self, obj)</code> Function for overloading the + operator. <code>operator_sub(self, obj)</code> Function for overloading the - operator. <code>operator_mul(self, obj)</code> Function for overloading the * operator. <code>operator_div(self, obj)</code> Function for overloading the / operator. <code>operator_idiv(self, obj)</code> Function for overloading the // operator. <code>operator_mod(self, obj)</code> Function for overloading the % operator. <code>operator_pow(self, obj)</code> Function for overloading the ^ operator. <code>operator_unm(self)</code> Function for overloading the unary \u2013 operator. <code>operator_eq(self, obj)</code> Function for overloading the == operator.\u00b9 <code>__tostring()</code> Fired when tostring is called on the object. <p>Info</p> <p>\u00b9: This function will only run when == operator is used with the same base type (table, userdata, etc.). It will not work with different types, such as an object with a table, or another type.</p> <p>Warning</p> <p>Trying to directly call the operator functions will result in an error. They must be called with their operators.</p>"},{"location":"tutorials/polymorphism/","title":"Polymorphism","text":"<p>In simple terms, Polymorphism stands for \"many forms\", it's one of the core concepts of OOP. It refers to situations where something occurs in several different forms, and describes the concept that you can access objects of different types through the same interface.</p> <p>Function Overloading, Operator Overloading, and Inheritance belong to this concept, for example with inheritance, we can create derived classes that have the same method name, but all do different things. Or with function overloading, every function has different arguments and does a different thing, but all share the same name. It provides flexibility, and extensibility.</p>"},{"location":"tutorials/polymorphism/#inheritance-example","title":"Inheritance Example","text":"<pre><code>local class = ClassPP.class\n\nlocal Animal = class \"Animal\" {\n    Public = {\n        animalSound = function(self)\n            print(\"The animal makes a sound\")\n        end\n    }\n}\n\n-- Derived class\nlocal Pig = class \"Pig\" (Animal, nil) {\n    Public = {\n        animalSound = function(self)\n            print(\"The pig says: oink oink\")\n        end\n    }\n}\n\n-- Derived class\nlocal Dog = class \"Dog\" (Animal, nil) {\n    Public = {\n        animalSound = function(self)\n            print(\"The dog says: woof woof\")\n        end\n    }\n}\n</code></pre>"},{"location":"tutorials/polymorphism/#function-overloading-example","title":"Function Overloading Example","text":"<pre><code>local class = ClassPP.class\n\nlocal Test = class \"Test\" {}\nTest.overload(\"Public\", \"Display\", {\n    function(self, number1)\n        print(\"Number: \", number1)\n    end,\n    function(self, number1, number2)\n        print(\"Numbers: \", number1, number2)\n    end\n})\n</code></pre>"},{"location":"tutorials/staticMembers/","title":"Static Members","text":"<p>Static members are members of the class that will exist regardless of whether or not any objects of the class are created. Once a static members has been created, they cannot be destroyed. Static members are also global, so all class objects have access to them, and their property will be the same across all of the objects.</p> <p>To create a static member in Class++, you have to use the <code>class.static(&lt;accessSpecifier&gt;, &lt;name&gt;, &lt;property&gt;)</code> function.</p> <pre><code>local class = ClassPP.class\n\nlocal Test = class \"Test\" {\n    Public = {\n        TestValue = 0\n    }\n}\n\nTest.static(\"Public\", \"StaticTestValue\", function(firstArgument)\n    print(firstArgument) -- This will not point to any object, instead it will print whatever it is called with! In this case, it will print \"Hi!\".\nend)\n\nlocal newTest = Test.new()\nnewTest:StaticTestValue() -- This will error!\n\nTest.StaticTestValue(\"Hi!\") -- This will work fine!\n</code></pre> <p>You can also give properties that aren't functions. So to retrieve those properties, you can do <code>class.&lt;memberName&gt;.property</code> or <code>class.&lt;memberName&gt;.p</code> for short.</p> <pre><code>local class = ClassPP.class\n\nlocal Test = class \"Test\" {\n    Public = {\n        TestValue = 0\n    }\n}\n\nTest.static(\"Public\", \"StaticTestValue\", 1)\n\nprint(Test.StaticTestValue.property) -- Prints \"1\"!\nprint(Test.StaticTestValue.p) -- Also prints \"1\"!\n</code></pre>"},{"location":"tutorials/types/","title":"Types","text":""},{"location":"tutorials/types/#intellisense","title":"Intellisense","text":"<p>Class++ has been rewritten from ground up, to support the new type-solver and its capabilities.  This allows Class++ to be more intelligent with the <code>class</code> and <code>object</code> types, finally allowing the intellisense to be far better than what it used to be. </p> <pre><code>local Person = class \"Person\" {\n    Public = {\n        Age = 0,\n        Name = \"\",\n        Personality = \"\",\n        Likes = {},\n        Dislikes = {},\n        Job = \"\",\n        getSecrets = function(self)\n            return self.Secrets\n        end,\n    },\n    Private = {\n        Secrets = {}\n    }\n}\n\nlocal newPerson = Person.new() -- Now has intellisense for members in all access specifiers, and obtains the correct types for every member!\n</code></pre> <p>This also applies to classes, where before you tried to create an inherited class, the returned class type would not be correct, and new objects would also not have the correct type. For example, some members of an inherited class would be missing from auto-complete.</p> <p>Now, this has also been fixed:</p> <pre><code>local class = ClassPP.class\n\nlocal A = class \"A\" { \n    Public = {\n        Variable_A = 1\n    }\n}\n\nlocal B = class \"B\" { \n    Public = {\n        Variable_B = 1\n    }\n}\n\nlocal C = class \"C\" (A, B) { -- Derived Class\n    Public = {\n        Variable_C = 1\n    }\n}\n\nlocal newObject = C.new() -- {Variable_A: number, Variable_B: number, Variable_C: number}\n</code></pre> <p>Though, as much as this update brings in an intellisense much better than before, it is still limited. Like in the previous versions of Class++, to support all the features of types in Luau, you have to create a custom type and assign it to the created objects.</p> <p>In the tutorial below, you will learn how to create a basic <code>Person</code> type and assign it to the created object, to enable the support.</p>"},{"location":"tutorials/types/#creating-a-basic-custom-class-type","title":"Creating a Basic Custom Class Type","text":"<pre><code>local class = ClassPP.class\n\ntype Person = {\n    Age: number,\n    Name: string,\n    Personality: string,\n    Job: string,\n    Secrets: {string},\n    Likes: {string},\n    Dislikes: {string},\n    getSecrets: (self: Person) -&gt; {string}\n}\n\nlocal Person = class \"Person\" {\n    Public = {\n        Age = 0,\n        Name = \"\",\n        Personality = \"\",\n        Likes = {},\n        Dislikes = {},\n        Job = \"\",\n        getSecrets = function(self: Person)\n            return self.Secrets\n        end,\n    },\n    Private = {\n        Secrets = {}\n    }\n}\n\nlocal newPerson: Person = Person.new()\n-- This object now fully supports all type features of Luau!\n</code></pre> <p>In the example above, we created a custom type called <code>Person</code> for the Person class, and inserted the types of all the members inside it, and declared the new created object as of the Person type. This now allows us to use all the features of Luau types.</p> <p>Info</p> <p>Since class objects belong to the base type <code>userdata</code>, you can type cast them to either your custom types, or any other existing type you wish.</p>"},{"location":"tutorials/types/#typechecking-for-classes-and-class-objects","title":"Typechecking for Classes and Class Objects","text":"<p>Class++ also comes with its own <code>Type</code> API that allows you to get the types of <code>class</code>es and <code>object</code>s.</p> <pre><code>local class = ClassPP.class\nlocal type, typeof = ClassPP.Type.type, ClassPP.Type.typeof\n\ntype Person = {\n    Age: number,\n    Name: string,\n    Personality: string,\n    Job: string,\n    Secrets: {string},\n    Likes: {string},\n    Dislikes: {string},\n    getSecrets: (self: Person) -&gt; {string}\n}\n\nlocal Person = class \"Person\" {\n    Public = {\n        Age = 0,\n        Name = \"\",\n        Personality = \"\",\n        Likes = {},\n        Dislikes = {},\n        Job = \"\",\n        getSecrets = function(self: Person)\n            return self.Secrets\n        end,\n    },\n    Private = {\n        Secrets = {}\n    }\n}\n\nlocal newPerson: Person = Person.new()\nprint(type(Person), \",\", type(newPerson)) -- Prints \"Class, Object\"!\nprint(typeof(Person), \",\", typeof(newPerson)) -- Prints \"Person, Person\"!\n</code></pre>"},{"location":"tutorials/types/#typetype","title":"Type.type","text":"<p><code>Type.type</code> will return the true type of the given object. It behaves the same as the built-in luau <code>type</code> function, but with additional support for <code>class</code>es and <code>object</code>s. For example, if the provided object is a <code>class</code>, it will return a string called \"Class\". This is due to the <code>class</code> object belonging to the base <code>Class</code> type.</p> <p>The same applies to <code>object</code>s, where if the provided object is an <code>object</code>, it will return a string called \"Object\". This is due to the <code>object</code> belonging to the base <code>Object</code> type.</p>"},{"location":"tutorials/types/#typetypeof","title":"Type.typeof","text":"<p><code>Type.typeof</code> will return the type of the given object. Like <code>Type.type</code>, it behaves the same as the built-in Roblox <code>typeof</code> function, but with additional support for <code>class</code>es and <code>object</code>s. For example, if the provided object is a <code>class</code>, it will return a string containing the name of the <code>class</code>. This is due to <code>class</code>es are also being types on their own. They can also be represented as types.</p> <p>For <code>object</code>s, this function will return the type of the <code>class</code> they belong to. For example, using this function with an <code>object</code> created from a \"Person\" <code>class</code>, will return \"Person\" as its type.</p> <p>Info</p> <p><code>Type.type</code> and <code>Type.typeof</code> functions can be used to replace the built-in <code>type</code> and <code>typeof</code> functions, as they behave the same with other provided objects. For example, using <code>Type.typeof</code> and <code>typeof</code> with a <code>string</code> will both return \"string\".</p> <p>Warning</p> <p>Using the <code>class.Name</code> property may create bugs in certain places as the Type API makes sure the given object is an actual <code>class</code> object before returning its type. It's recommended that you use the Type API instead of the <code>.Name</code> property.</p>"}]}